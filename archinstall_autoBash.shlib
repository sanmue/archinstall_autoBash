#!/usr/bin/env bash
# shellcheck disable=SC2154

# set -x   # enable debug mode

# ----------------------------------------------------------------
# Name                 archinstall_autoBash.shlib
# Description          Functions used by the shell scripts
# Author               Sandro Müller (sandro(ÄT)universalaccount.de)
# Licence              GPLv3
# ----------------------------------------------------------------

# ---------
# Functions
# ---------
check-bashVersion() {
    # Parameter 1: min. required (major) bash version

    if [ "${BASH_VERSINFO[0]}" -lt "${1}" ]; then
        echo -e "Current bash version: ${BASH_VERSINFO[0]}\nMin. required version: '${1}'\nexit, sorry"
        exit 1
    fi
}

check-devicePath() {
    # Parameter 1: device path (e.g. /dev/vda)

    echo "Checking if '${1}' is available"
    if [ ! -b "${1}" ]; then   # if ${device} ("file") not available
        echo -e "\e[0;33m!!! '${1}' not found !!!\e[39m \nExit the script"
        exit 1
    fi
}

check-exitStatusLastCommand() {
    # Parameter 1: exit status (0 = no error)

    if [ "${1}" -ne 0 ]; then
        echo -e "\e[0;31m----------------------------------------\e[0m"
        echo -e "\e[0;31mERROR - Exit status last command: '${1}'\e[0m"
        echo -e "\e[0;31m----------------------------------------\e[0m"
        echo "Press Enter to continue." && read -r
    fi
}

erase-device() {
    # Parameter 1: device path (e.g. /dev/vda)
    # Parameter 2: blocksize

    if [ "${eraseDisk}" = "true" ]; then   # Erase (overwrite) device
        echo -e "\e[0;33m!!! Erasing '${1}', will take some time... !!!\e[0m"
        echo "Press Enter to continue or '<CTRL> + <C>' to cancel"   # only for testing
        read -r                                                      # only for testing
        dd if=/dev/urandom of="${1}" bs="${2}" status=progress       # TODO: test # erase device by copying random bytes to the whole disk
    fi
}

partition-disk() {
    # Parameter 1: bootmode (Bios or Uefi)
    # Parameter 2: partition type (gpt or mbr) (Uefi: only gpt)
    # Parameter 3: device path (e.g. /dev/vda)
    # Parameter 4: size of swap partition
    # Parameter 5: size of EFI partition (only when Uefi bootmode)

    if [ "${1}" = "Bios" ]; then
        partition-diskBios "${2}" "${3}" "${4}"
    else
        partition-diskUefi "${3}" "${4}" "${5}"
    fi
}

partition-diskBios() {
    # Parameter 1: partition type (gpt or mbr)
    # Parameter 2: device path (e.g. /dev/vda)
    # Parameter 3: size of swap partition

    if [ "$1" = "gpt" ]; then
        # partition type "gpt"
        (
        echo g   # --- create a new empty GPT partition table ---

        echo n   # --- add a new partition: Small 1 MB partition ---
        echo     # accept default value (Partition No: 1)
        echo     # accept default value (Start first sector)
        echo +1M # partition size
        echo t   # change partition type
        echo 4   # Type: Bios boot

        echo w   # Write changes
        ) | sudo fdisk "${2}" 1>/dev/null

        if [ "${swapType}" = "partition" ]; then
            (
            echo n   # --- add a new partition: Swap ---
            echo     # accept default value (Partition No: 2)
            echo     # accept default value (Start of first sector)
            echo +"${3}"M # partition size
            echo t   # change partition type
            echo     # accept default value (Partition No: 2)
            echo 19  # Type: Linux swap

            echo w   # Write changes
            ) | sudo fdisk "${2}" 1>/dev/null
        fi

        (
        echo n   # --- add a new partition: root ---
        echo     # accept default value (Partition No: 3, or 2 (if no swap partition))
        echo     # accept default value (start of first sector)
        echo -1M # # leaves small unallocated space of 1MB at the end of the disk
        echo t   # change partition type
        echo
        echo 23  # Type: Linux root (x86-64)

        echo w   # Write changes
        ) | sudo fdisk "${2}" 1>/dev/null
    else
        # partition type "mbr"
        (
            echo o   # --- create a new empty MBR (DOS) partition table ---
            echo w   # Write changes
        ) | sudo fdisk "${2}" 1>/dev/null

        if [ "${swapType}" = "partition" ]; then
            (
            echo n   # --- add a new partition: Swap ---
            echo p   # primary (partition type)
            echo     # accept default value (Partition No: 1)
            echo     # accept default value (Start of first sector)
            echo +"${3}"M # partition size
            echo t   # change partition type
            echo     # accept default value (Partition No: 1)
            echo 82  # Type: Linux swap / Solaris
            echo w   # Write changes
            ) | sudo fdisk "${2}" 1>/dev/null
        fi

        (
        echo n   # --- add a new partition: root ---
        echo p   # primary (partition type)
        echo     # accept default value (Partition No: 2, or 1 if no swap partition)
        echo     # accept default value (start of first sector)
        echo -1M # leaves small unallocated space of 1MB at the end of the disk

        echo w   # Write changes
        ) | sudo fdisk "${2}" 1>/dev/null
    fi

    fdisk -l # display partitions
}

partition-diskUefi() {
    # Parameter 1: device path (e.g. /dev/vda)
    # Parameter 2: size of swap partition
    # Parameter 3: size of EFI partition

    (
    echo g   # --- create a new empty GPT partition table ---

    echo n   # --- add a new partition: EFI boot partition ---
    echo     # accept default value (Partition No: 1)
    echo     # accept default value (Start first sector)
    echo +"${3}"M # partition size
    echo t   # change partition type
    echo     # accept default value (Partition No: 1)
    echo 1   # Type: EFI System

    echo w   # Write changes
    ) | sudo fdisk "${1}" 1>/dev/null

    sleep 2 # TEST-workaround since sometimes creating root partition failed because of 'device busy' (VM on external USB (SSD) device) # TODO

    if [ "${swapType}" = "partition" ]; then
        (
        echo n   # --- add a new partition: Swap ---
        echo     # accept default value (Partition No: 2)
        echo     # accept default value (Start of first sector)
        echo +"${2}"M # partition size
        echo t   # change partition type
        echo     # accept default value (Partition No: 2)
        echo 19  # Type: Linux swap
        echo w   # Write changes
        ) | sudo fdisk "${1}" 1>/dev/null
    fi

    sleep 2 # TEST-workaround since sometimes creating root partition failed because of 'device busy' (VM on external USB (SSD) device) # TODO

    (
    echo n   # --- add a new partition: root ---
    echo     # accept default value (Partition No: 3)
    echo     # accept default value (start of first sector)
    echo     # accept default value (end of last sector (Remainder of device))
    echo t   # change partition type
    echo
    echo 23  # Type: Linux root (x86-64)

    echo w   # Write changes
    ) | sudo fdisk "${1}" 1>/dev/null

    fdisk -l # display partitions
}

format-partition() {
    # Parameter 1: device
    # Parameter 2: bootMode
    # Parameter 3: partitionType
    # Parameter 4: filesystemType
    # Parameter 5: fileSystemTypeEfi
    # Parameter 6: fatSize
    # Parameter 7: partitionLabelRoot
    # Parameter 8: partitionLabelEfi
    # Parameter 9: partitionLabelHome
    # Parameter 10: partitionLabelSwap

    # TODO: check path of partition device name

    # ### ---------------
    # ### set partitionNo
    # ### ---------------
    if [ "${2}" = "Bios" ] && [ "${3}" = "gpt" ]; then                  # --- Bios + gpt
        # Partition No 1: empty, no formating
        if [ "${swapType}" = "partition" ]; then
            set-partitionNo "swap" "2" # e.g. sets: swapPartitionNo="2" (-> /dev/vda2 or /dev/nvme0n1p2 or /dev/mmcblk1p2 or ...)
            set-partitionNo "root" "3" # e.g. sets: rootPartitionNo="3" (-> /dev/vda3 or /dev/nvme0n1p3 or /dev/mmcblk1p3 or ...)
        else
            # no swap partion ('file' or 'none')
            set-partitionNo "root" "2"
        fi

    elif [ "${2}" = "Bios" ] && [ "${3}" = "mbr" ]; then                # --- Bios + mbr
        if [ "${swapType}" = "partition" ]; then
            set-partitionNo "swap" "1"
            set-partitionNo "root" "2"
        else
            # no swap partion ('file' or 'none')
            set-partitionNo "root" "1"
        fi

    else                                                                # --- Uefi + gpt
        set-partitionNo "efi" "1"
        if [ "${swapType}" = "partition" ]; then
            set-partitionNo "swap" "2"
            set-partitionNo "root" "3"
        else
            # no swap partion ('file' or 'none')
            set-partitionNo "root" "2"
        fi
    fi

    # ### ---
    # Save device root partition to file (e.g.: /dev/vda2)
    # - will be read from in chroot, needed for keyfile: cryptsetup luksAddKey /dev/vda2 ...
    # only relevant when using GRUB bootloader; systemd-boot: /efi partition not encrypted -> only 1x password input to decrypt root
    # ### ---
    echo "${1}${rootPartitionNo}" | tee "${fileRootPartition}" >/dev/null

    # ### -----------------
    # ### Format partitions
    # ### -----------------

    if [ "${encryption}" = "true" ]; then
        # https://wiki.archlinux.org/title/Dm-crypt

        # --- START: root partition
        #
        # https://man.archlinux.org/man/core/cryptsetup/cryptsetup-luksFormat.8.en
        # https://wiki.archlinux.org/title/Dm-crypt/Device_encryption#Encrypting_devices_with_cryptsetup
        # GRUB's support for LUKS2 is limited; see GRUB#Encrypted /boot for details.
        echo -e "\nEnrypting root partition..."
        result=6666  # arbitrary number not equal to 0 (0 = no error in last command)
        while [ "$result" -ne 0 ]; do
            if [ "$result" -ne 6666 ]; then echo -e "\e[1;33mPlease try again, something did not work.\e[0m"; fi
            cryptsetup luksFormat --pbkdf pbkdf2 --label "${encryptionRootName}" "${1}${rootPartitionNo}"   # Lable (-L) needed in function 'config-bootloader' for easy grep of UUID of root partition from blkid
            result=$?
        done

        echo -e "\nOpening encrypted root partition..."
        result=6666 # arbitrary number not equal to 0 (0 = no error in last command))
        while [ "$result" -ne 0 ]; do
            cryptsetup open "${1}${rootPartitionNo}" "${encryptionRootName}" # https://man.archlinux.org/man/core/cryptsetup/cryptsetup-open.8.en
            # https://man.archlinux.org/man/core/cryptsetup/cryptsetup-open.8.en
            # cryptsetup open -v --type luks2 "${1}${rootPartitionNo}" "${encryptionRootName}"
            result=$?
        done

        if [ "${4}" = "btrfs" ]; then
            #mkfs."${4}" -f -L "${7}" -n 32k "${encryptionRootPath}"        # format root-partition, btrfs, force (-f), label (-L), blocksize (-n) # TODO: config variable for blocksize
            mkfs."${4}" -f -L "${7}" "${encryptionRootPath}"
        elif [ "${4}" = "ext4" ]; then
            mkfs."${4}" -F -L "${7}" "${encryptionRootPath}"                # format root-partition, ext4, force (-F), label (-l) # encryptionRootPath e.g.: '/dev/mapper/cryptroot'
        else
            mkfs."${4}" "${encryptionRootPath}"                             # format root-partition, other filesystems
        fi
        # --- END: root partition

        # --- START: swap
        if [ "${swapType}" = "partition" ]; then
            # mkswap "${1}${swapPartitionNo}" # make swap-partition, no encryption
            #
            # https://wiki.archlinux.org/title/Dm-crypt/Swap_encryption#UUID_and_LABEL
            # - It is more reliable to identify the correct partition by giving it a genuine UUID or LABEL.
            mkfs.ext2 -L "${10}" "${1}${swapPartitionNo}" 1M # create small, empty, bogus filesystem to provide a persistent UUID or LABEL for the swap encryption.
        fi
        # --- END: swap

    else # no encryption
        # --- START: root partition
        if [ "${4}" = "btrfs" ]; then
            mkfs."${4}" -f -L "${7}" -n 32k "${1}${rootPartitionNo}"        # format root-partition, btrfs, force (-f), label (-L), blocksize (-n)   # TODO: config variable for blocksize
        elif [ "${4}" = "ext4" ]; then
            mkfs."${4}" -F -L "${7}" "${1}${rootPartitionNo}"               # format root-partition, ext4, force (-F), label (-L)
        else
            mkfs."${4}" "${1}${rootPartitionNo}"                            # format root-partition, other filesystems
        fi
        # --- END: root partition

        # --- START: swap partition
        if [ "${swapType}" = "partition" ]; then
            mkswap "${1}${swapPartitionNo}"                                 # make swap-partition
        fi
        # --- END: swap partition
    fi

    # --- swapfile
    # - will be done in function 'mount-partition', since then btrfs subols will be created, including subvol for swapfile
    # - if not btrfs + subvol: could be done here, but want to keep it together

    # --- START: efi partition:
    if [ ! "${efiPartitionNo}" = "0" ]; then # && [ "${2}" = "Uefi" ]; then # if efiPartitionNo has not initial default value (from config) und bootMode = Uefi
        mkfs."${5}" -F "${6}" -n "${8}" "${1}${efiPartitionNo}" # format efi-partition
    fi
    # --- END: efi partition:
}

set-partitionNo() {
    # Parameter 1: type                     # e.g. "efi", "swap" or "root"
    # Parameter 2: partitionNo              # e.g. "1"
                                            # https://wiki.archlinux.org/title/Device_file#Partition
    local separator="p"                     # if device name ends with a number, drive name and partition number is separated with the letter "p"

    if [[ "${device}" = *[0-9] ]]; then     # if device name ends with a number
        local partitionNo="${separator}${2}"
    else
        local partitionNo="${2}"
    fi

    case "${1}" in
        "efi")
            efiPartitionNo="${partitionNo}"
        ;;

        "swap")
            swapPartitionNo="${partitionNo}"
        ;;

        "root")
            rootPartitionNo="${partitionNo}"
        ;;

        *)
            echo -e "\e[0;31m case default - function 'set-partitionNo': type not found, exit. \e[0m"
            exit 1
        ;;
    esac
}

mount-partitionRootInitial() {
    # Parameter 1: device (e.g. '/dev/vda') or "encryptionDeviceMapperPath/" (e.g. '/dev/mapper/')
    # Parameter 3: rootPartitionNo (e.g. '3') or encryptionRootName (e.g. 'cryptroot')
    # Parameter 4: mount target (e.g. '/mnt')

    # echo "P1 device: ${1}; P2 filesystemType: ${2}; P3 rootPartitionNo: ${3}; P4 mount target: ${4}"

    # initial mount, no mount options needed
    # currently only relevant for btrfs: to create subvolumes
    echo "mount ${1}${3} ${4}"
    mount "${1}${3}" "${4}" # root-partition, fix, mount without mount options
    # echo "mount ${1}${3} ${mountOption} ${4}"
    # mount "${1}${3}" "${mountOption}"  "${4}" # root-partition, mount with mount options
}

mount-partition() { # mounting all partitions (if btrfs: including subvolumes) as preparation for installation; and snapper-rollback folder
                    # https://wiki.archlinux.org/title/Snapper#Configuration_of_snapper_and_mount_point
    # Parameter 1: device (e.g. '/dev/vda')
    # Parameter 2: bootMode
    # Parameter 3: filesystemType
    # Parameter 4: efiPartitionNo  # (e.g. '1' -> P1:device + P4:this number = '/dev/vda1')
    # Parameter 5: swapPartitionNo # (e.g. '2') # if no swap partition (swaptype 'file' or 'none') -> default '0' (see config file)
    # Parameter 6: rootPartitionNo # (e.g. '3')
    # Parameter 7: mount target (e.g. /mnt)
    # Parameter 8: swapFileName # only needed for swap file + NO btrfs with subvols (not for swap partition)
    # Parameter 9: swapFilePath # only needed for swap file and btrfs + subvol (not for swap partition)
    # Parameter 10: swapSize (only needed for swap file (not for swap partition))

    # --- root partition - filsystem specific mount options
    # ! root partition must be mounted first or it hides e.g. /mnt/efi !
    case "${3}" in
        "btrfs")
            # mount every subvolume and create related folder if necessary
            echo "Mounting all btrfs subvolumes..."

            echo "- mounting root subvolume to '${7}'"   # or creating mount targets for the other subvolumes will fail + can not be mounted
            for subvol in "${!btrfsSubvolLayout[@]}"; do
                if [ "${btrfsSubvolLayout[${subvol}]}" = "/" ]; then
                    if [ "${encryption}" = "true" ]; then
                        echo "mount -o ${mountOptionBtrfs},subvol=${subvol} ${encryptionRootPath} ${7}"
                        mount -o "${mountOptionBtrfs},subvol=${subvol}" "${encryptionRootPath}" "${7}"
                    else
                        echo "mount -o ${mountOptionBtrfs},subvol=${subvol} ${1}${6} ${7}"
                        mount -o "${mountOptionBtrfs},subvol=${subvol}" "${1}${6}" "${7}"
                        #mount -o "${mountOptionBtrfs},subvol=${subvol}" "${1}${6}" "${7}${btrfsSubvolLayout[${subvol}]}"  # e.g. mount -o rw,noatime,discard=async,compress=zstd,space_cache=v2,subvol=@ /dev/vda3 /mnt/
                    fi

                    break   # no need to go through the rest of the hashtable, if root subvolume is found
                fi
            done

            echo "- creating mount targets for subvolumes, if they do not exist..."
            for subvol in "${!btrfsSubvolLayout[@]}"; do
                if [ "${subvol}" = "@" ]; then                             # special handling for root subvolume @; no need to create root folder '/'
                    continue
                fi

                if [ ! -e  "${7}${btrfsSubvolLayout[${subvol}]}" ]; then   # if mount target (folder) does NOT exist
                    echo -e "\e[0;33m    |__ mount target '${7}${btrfsSubvolLayout[${subvol}]}' does not exist, folder will be created...\e[0m" # e.g. /mnt/home
                    mkdir -p "${7}${btrfsSubvolLayout[${subvol}]}"

                    if [ "${7}${btrfsSubvolLayout[${subvol}]}" = "${7}${snapperSnapshotFolder}" ]; then   # e.g.: if /mnt/.snapshots
                        chmod -R 750 "${7}${btrfsSubvolLayout[${subvol}]}" && chown -R :wheel "${7}${btrfsSubvolLayout[${subvol}]}"
                    fi
                fi
            done

            if [ "${snapperRollback}" = true ]; then
                echo "- creating mount targets for snapperRollbackFolder, if it does not exist..."
                if [ ! -e  "${7}${snapperRollbackFolder}" ]; then   # if mount target (folder) does NOT exist
                    echo -e "\e[0;33m    |__ mount target '${7}${snapperRollbackFolder}' does not exist, folder will be created...\e[0m" # e.g. /mnt/home
                    mkdir -p "${7}${snapperRollbackFolder}"
                    chmod -R 750 "${7}${snapperRollbackFolder}" && chown -R :wheel "${7}${snapperRollbackFolder}"
                fi
            fi

            echo "- mounting subvolumes..."
            for subvol in "${!btrfsSubvolLayout[@]}"; do
                if [ "${subvol}" = "@" ]; then                             # special handling for root subvolume @, already mounted (very first step in current function)
                    continue
                fi

                if [ "${encryption}" = "true" ]; then
                    mount -o "${mountOptionBtrfs},subvol=${subvol}" "${encryptionRootPath}" "${7}${btrfsSubvolLayout[${subvol}]}"   # e.g. .../dev/mapper/cryptroot /mnt/home
                else
                    mount -o "${mountOptionBtrfs},subvol=${subvol}" "${1}${6}" "${7}${btrfsSubvolLayout[${subvol}]}"  # e.g. mount -o rw,noatime,discard=async,compress=zstd,space_cache=v2,subvol=@home /dev/vda3 /mnt/home
                fi
            done

            if [ "${snapperRollback}" = true ]; then
                echo "- mounting snapperRollbackFolder..."
                if [ "${encryption}" = "true" ]; then
                    mount -o "${mountOptionBtrfs},subvol=/" "${encryptionRootPath}" "${7}${snapperRollbackFolder}"   # e.g. .../dev/mapper/cryptroot /mnt/.btrfsroot
                else
                    mount -o "${mountOptionBtrfs},subvol=/" "${1}${6}" "${7}${snapperRollbackFolder}"  # e.g. mount -o rw,noatime,discard=async,compress=zstd,space_cache=v2,subvol=@home /dev/vda3 /mnt/.btrfsroot
                fi
            fi
        ;;

        *)
            # other filesystems
            if [ -z "${mountOptionDefault}" ]; then   # no options configured, let mount command go for it
                if [ "${encryption}" = "true" ]; then
                    echo "mount ${encryptionRootPath} ${7}"
                    mount "${encryptionRootPath}" "${7}"
                else
                    echo "mount ${1}${6} ${7}"
                    mount "${1}${6}" "${7}"
                fi
            else
                if [ "${encryption}" = "true" ]; then
                    echo "mount -o ${mountOptionDefault} ${encryptionRootPath} ${7}"
                    mount -o "${mountOptionDefault}" "${encryptionRootPath}" "${7}"
                else
                    echo "mount -o ${mountOptionDefault} ${1}${6} ${7}"
                    mount -o "${mountOptionDefault}" "${1}${6}" "${7}"
                fi
            fi
        ;;
    esac

    # --- SWAP
    # needs to be mounted AFTER mounting root at /mnt (see comment below for EFI)
    if [ "${swapType}" = "partition" ]; then
        if [ "${encryption}" = "true" ]; then
            echo -e "\e[0;33m- Swap partition - config option 'encryption=true': not mounting swap at this point. Swap partition with encryption will be handled separately.\e[0m"
        else
            echo "- mounting swap..."
            swapon "${1}${5}"                  # swap-partition # e.g. swapon /dev/vda2
        fi
    elif [ "${swapType}" = "file" ]; then
        if [ "${3}" = "btrfs" ]; then
            # - https://wiki.archlinux.org/title/Btrfs#Swap_file
            btrfs filesystem mkswapfile --size "${10}M" --uuid clear "${7}${9}"
            swapon "${7}${9}"
        else
            # https://wiki.archlinux.org/title/Swap#Swap_file_creation
            mkswap -U clear --size "${10}M" --file "${7}/${18}"
            swapon "${7}/${8}"
        fi
    fi

    # --- EFI
    # if ERROR Failed to get canonical path of /efi when installing boot loader (e.g. GRUB):
    # - https://bbs.archlinux.org/viewtopic.php?id=267084
    # - Mounting /mnt AFTER /mnt/efi hides /mnt/efi beneath the new /mnt -> EFI partition needs to be mounted AFTER mounting root at /mnt
    if [ "${2}" = "Uefi" ]; then               # bootMode: Uefi
        echo "- creating mount target for efi-partition..."
        mkdir -p "${7}${pathEfi}"              # e.g. /mnt/efi or /mnt/boot/efi
        echo "- mounting efi-partition..."
        mount "${1}${4}" -o "${mountOptionEfi}" "${7}${pathEfi}" # EFI-partition # e.g. mount /dev/vda1 -o fmask=0137,dmask=0027 /mnt/efi
    fi
}

create-btrfsSubvolume() {             # https://wiki.archlinux.org/title/Btrfs#Subvolumes
    # Parameter 1: mount target of root subvolume (e.g. /mnt)

    # want the root subvolume (mount point '/'') being the first (-> ID 256) # actually not necessary, just for looks:
    for subvol in "${!btrfsSubvolLayout[@]}"; do
        if [ "${btrfsSubvolLayout[${subvol}]}" = "/" ] && [ ! -e "${1}/${subvol}" ]; then   # if root subvolume NOT already present (should be the case here)
            echo "|__ creating subvolume '${subvol}'..."
            btrfs subvolume create "${1}/${subvol}"                                         # e.g.: btrfs subvolume create "/mnt/@"
            break                                                                           # not necessary to search further
        fi
    done

    # creating the other subvolumes according to the configured layout:
    for subvol in "${!btrfsSubvolLayout[@]}"; do
        if [ ! -e "${1}/${subvol}" ]; then                                                  # if subvolume NOT already present
            echo "|__ creating subvolume '${subvol}'..."
            sudo btrfs subvolume create "${1}/${subvol}"
        else
            echo -e "\e[0;33m|__ Subvolume '${1}/${subvol}' already present\e[0m"
        fi
    done
}

create-fstab() {   # function not used; btrfs subvolumes get mounted and then genfstab does the job
    #if [ "${filesystemType}" = "btrfs" ] && [ "${deviceType}" = "ssd" ]; then
    if [ "${filesystemType}" = "btrfs" ]; then
        fstabPath="/mnt/etc/fstab"   # "${fstabPath}"
        #fstabPath="/etc/fstab"      # "${fstabPath}"

        #touch "${fstabPath}"
        #echo "# <file system> <dir> <type> <options> <dump> <pass>" > "${fstabPath}"   # fstab with inital comments already available

        # --- EFI-Partition (Uefi only)
        if [ "${bootMode}" = "Uefi" ]; then
            uuid=$(lsblk -n -o UUID "/dev/${deviceName}${efiPartitionNo}" | xargs)
            echo -e "\n# /dev/${deviceName}${efiPartitionNo} LABEL=${partitionLabelEfi}" >> "${fstabPath}"
            echo "UUID=${uuid} ${pathEfi} vfat defaults,noatime 0 2" >> "${fstabPath}"   # e.g. UUID=DE99-988D /efi vfat defaults,noatime 0 2
        fi

        # --- swap partition
        if [ "${swapType}" = "partition" ]; then
            uuid=$(lsblk -n -o UUID "/dev/${deviceName}${swapPartitionNo}" | xargs)
            echo -e "\n# /dev/${deviceName}${swapPartitionNo} (swap)" >> "${fstabPath}"
            echo "UUID=${uuid} none swap defaults 0 0" >> "${fstabPath}" # e.g.: UUID=656d357b-c3e8-4ae2-8122-1675c9e08edc none swap defaults 0 0
        fi

        # --- root partition
        uuid=$(lsblk -n -o UUID "/dev/${deviceName}${rootPartitionNo}" | xargs)
        echo "${uuid}"

        echo -e "\n# /dev/${deviceName}${rootPartitionNo} LABEL=${partitionLabelRoot}" >> "${fstabPath}"
        create-fstab4BtrfsRootPartition "${fstabPath}" "${uuid}" "/mnt"  # e.g.: # UUID=656d357b-c3e8-4ae2-8122-1675c9e08edc / btrfs subvol=/@,noatime,discard=async,compress=zstd,space_cache=v2 0 0
    else # if not btrfs
        genfstab -U /mnt >> "${fstabPath}"
    fi
}

create-fstab4BtrfsRootPartition() {   # function not used; btrfs subvolumes get mounted and the genfstab does the job
    # Parameter 1: fstabPath (including /mnt)
    # Parameter 2: uuid
    # Parameter 3: mountpoint   # e.g. /mnt

    local mountPoint="${3}"

    get-rootSubvolumeName   # function reads from 'btrfsSubvolLayout' and sets current value for variable 'rootSubvolumeName' # e.g. '@'
    echo "Want to make sure, that btrfs root subvolume '${rootSubvolumeName}' is the first entry in fstab:"   # justs for the looks
    echo "UUID=${2} / btrfs ${mountOptionBtrfs},subvol=/${rootSubvolumeName} 0 0" | sudo tee -a "${1}"

    echo -e "\n*** Creating fstab entries for root partition with btrfs subvolumes"
    for subvol in "${!btrfsSubvolLayout[@]}"; do
        subvolInFstab='false'
        mountPointInFstab='false'

        echo "|__ creating entry for subvolume '${subvol}' with mount point '${btrfsSubvolLayout[${subvol}]}'..."

        if [ ! -e  "${mountPoint}${btrfsSubvolLayout[${subvol}]}" ]; then       # if mount target (folder) NOT existing
            echo -e "\e[0;33m    |__ mount target '${mountPoint}${btrfsSubvolLayout[${subvol}]}' does not exist, folder will be created...\e[0m"
            sudo mkdir -p "${mountPoint}${btrfsSubvolLayout[${subvol}]}"
        fi

        if [[ $(grep "subvol=/${subvol}," "${1}") ]]; then                      # if entry for options (e.g. ...'subvol=/@,'...) already present in fstab
            echo -e "\e[0;33m    |__ entry for subvolume '${subvol}' already present, check and correct if necessary\e[0m"
            subvolInFstab='true'
        fi

        if [[ $(grep -E " +${btrfsSubvolLayout[${subvol}]} +" "${1}") ]]; then  # if mount target (e.g. for '/') already present in fstab
            echo -e "\e[0;33m    |__ mount target '${btrfsSubvolLayout[${subvol}]}' already present, will not create entry '${subvol}' (again), check and correct if necessary\e[0m"
            mountPointInFstab='true'
        fi

        if [ "${subvolInFstab}" = 'false' ] && [ "${mountPointInFstab}" = 'false' ]; then   # if not already present create entry for subvolume in fstab
            # e.g.: UUID=656d357b-... / btrfs subvol=/@,noatime,discard=async,compress=zstd,space_cache=v2 0 0
            echo "UUID=${2} ${btrfsSubvolLayout[${subvol}]} btrfs ${mountOptionBtrfs},subvol=/${subvol} 0 0" | sudo tee -a "${1}"
        fi
    done
}

set-btrfsDefaultSubvolume() {
    # Parameter 1: path   # e.g. /mnt or /

    get-rootSubvolumeName   # function reads from 'btrfsSubvolLayout' and sets current value for variable 'rootSubvolumeName' # e.g. '@'

    if [ -d "${1}" ]; then
        # e.g.: ID 256 gen 7 top level 5 path @   # rootSubvolumeName: '@''
        rootSubvolumeID=$(btrfs subvolume list "${1}" | grep -w "${rootSubvolumeName}" | cut -d ' ' -f 2 | xargs)  # e.g. 256

        if [ -n "${rootSubvolumeID}" ]; then
            btrfs subvolume set-default "${rootSubvolumeID}" "${1}" # e.g.: btrfs subvolume set-default "256" /mnt
        else
            echo -e"\e[0;31m!!! Could not set default btrfs subvolume !!!\e[0m"
            echo "Trying to set ID '256' as default subvolume (root subvolume @)..."
            btrfs subvolume set-default 256 "${1}"
        fi
    else
        echo -e"\e[0;31m!!! function set-btrfsDefaultSubvolume(): Given path does not exist !!!\e[0m"
    fi
}

get-rootSubvolumeName() {
    for subvol in "${!btrfsSubvolLayout[@]}"; do
        if [ "${btrfsSubvolLayout[${subvol}]}" = "/" ]; then    # if root subvolume (mount target '/')
            rootSubvolumeName="${subvol}"
            echo "rootSubvolumeName: '${rootSubvolumeName}'"
            break                                               # not necessary to search further
        fi
    done
}

modify-fstab() {
    # Parameter 1: target file    # e.g. /mnt/etc/fstab

    if [ "${filesystemType}" = "btrfs" ]; then   # e.g.: btrfs: genfstab adds ...,subvolid=XXX,... to the mount options, which we do not want with regard to snapshots
        sed -i -e 's/,subvolid=[0-9][0-9][0-9]//' "${1}"
    fi
}

config-snapper() {   # should work after finished install + reboot, but not in chroot-environment (and when no config for root + subvol .snapshots # TODO: !! not tested !! )
    # https://wiki.archlinux.org/title/Snapper

    # Parameter 1: name for the config      (e.g. "root" ("${snapperConfigName_root}"))
    # Parameter 2: path to the subvolume    (e.g. '/' for the path to root subvolume)

    local configName="${1}"
    local pathToSubvolume="${2}"

    pacman -Sy --needed --noconfirm snapper inotify-tools           # just to be sure, should already be installed (if 'install-additionalPackages' was called in a step before)
    pacman -S --needed --noconfirm snap-pac                         # Pacman hooks that use snapper to create pre/post btrfs snapshots like openSUSE's YaST
    if [ "${bootloader}" = "grub" ]; then pacman -S --needed --noconfirm grub-btrfs; fi # Include btrfs snapshots in GRUB boot options # just to be sure, should already be installed (if 'install-additionalPackages' was called in a step before)

    snapper -c "${configName}" create-config "${pathToSubvolume}"   # among others creates a subvolume at "/path/to/subvolume/.snapshots" (which should already exist when using the startconfig in 'btrfsSubvolLayout')

    for snapperConfKey in "${!snapperSnapshotConf[@]}"; do          # configuring the snapper config '$configName'
        snapper -c "${configName}" set-config "${snapperConfKey}=${snapperSnapshotConf[${snapperConfKey}]}"   # e.g.: snapper -c root set-config "ALLOW_GROUPS=wheel"
    done

    #systemctl enable snapper-timeline.timer                        # I do not want timeline snapshots; see 'snap-pac' # TODO: config option for creating timeline snapshot (too)
    systemctl enable snapper-cleanup.timer                          # just to be sure, should also be enabled later when calling 'enable-service' # periodically clean up older snapshots
    if [ "${bootloader}" = "grub" ]; then systemctl enable grub-btrfsd.service; fi  # Include btrfs snapshots in GRUB boot options # just to be sure # Regenerate grub-btrfs.cfg
}

config-snapperLiveEnv() { # when booted in live environment
    # https://wiki.archlinux.org/title/Snapper
    # https://wiki.archlinux.org/title/Snapper#Configuration_of_snapper_and_mount_point

    # Parameter 1: name for the config                      (e.g. "root" ("${snapperConfigName_root}"))
    # Parameter 2: current (temp.) path to the subvolume    (e.g. '/mnt' for the path to root subvolume)
    # Parameter 3: path to the subvolume ("real" system)    (e.g. '/' for the path to root subvolume)

    local configName="${1}"
    local pathToSubvolume_tmp="${2}"
    local pathToSubvolume_real="${3}"

    # install needed packages in live environment:
    pacman -Sy && pacman -S --needed --noconfirm snapper inotify-tools  # this is just for/in Live Environment # 'strListAdditionalPkg' already contains/installed the needed packages (snapper inotify-tools snap-pac grub-btrfs)

    # unmount subvolume for snapshots (-> 'btrfsSubvolLayout')
    umount "${pathToSubvolume_tmp}${snapperSnapshotFolder}"             # e.g. /mnt/.snapshots # https://wiki.archlinux.org/title/Snapper#Configuration_of_snapper_and_mount_point

    # delete the ''.snaphots' folder (or the snapper ... creat-config ... in next step fails)
    rm -rf "${pathToSubvolume_tmp}${snapperSnapshotFolder}"             # e.g. '/mnt/.snapshots' # 'snapper ... create-config ...' wants to create the snapshot folder and fails if already present

    # create snapper config file
    snapper -c "${configName}" create-config "${pathToSubvolume_tmp}"   # e.g. snapper -c root create-config /mnt # (besides config files) creates a subvolume '.snapshots' at "/path/to/subvolume"
                                                                        #                                                                  (which should already exist when using the startconfig in 'btrfsSubvolLayout')
    # remove the btrfs subvolume '.snapshots' (and the folder /mnt/.snapshots); wo already have a subvolume e.g '@snapshots' (-> 'btrfsSubvolLayout')
    rm -rf "${pathToSubvolume_tmp}${snapperSnapshotFolder}"

    # ... that means we (only) have to create the folder again (e.g. /mnt/.snapshots) and give it again the access-rights + owner (as initially in function 'mount-partition'):
    mkdir "${pathToSubvolume_tmp}${snapperSnapshotFolder}"
    chmod -R 750 "${pathToSubvolume_tmp}${snapperSnapshotFolder}" && chown -R :wheel "${pathToSubvolume_tmp}${snapperSnapshotFolder}"
    # mount -o subvol=@snapshots /dev/vda3 /mnt/.snapshots              # not necessary to mount again, everything mounted beyond '/mnt' will be unmounted in the next (last) step anyway

    for snapperConfKey in "${!snapperSnapshotConf[@]}"; do              # configuring the snapper config '$configName'
        snapper -c "${configName}" set-config "${snapperConfKey}=${snapperSnapshotConf[${snapperConfKey}]}"   # e.g.: snapper -c root set-config "ALLOW_GROUPS=wheel"
    done

    # correct config for 'configName': 'pathToSubvolume_tmp' to 'pathToSubvolume_real'   # e.g. '/mnt' to '/' in "/etc/snapper/configs/${configName}"
    sed -i "s|${pathToSubvolume_tmp}|${pathToSubvolume_real}|g" "/etc/snapper/configs/${configName}"   # e.g.: sed -i "s|/mnt|/|g" /etc/snapper/configs/root

    # copy the (corrected) snapper config files created in the Live Environment to their place in the mounted root subvolume
    mkdir -p "${pathToSubvolume_tmp}/etc/snapper/configs" && cp "/etc/snapper/configs/${configName}" "${pathToSubvolume_tmp}/etc/snapper/configs/"
    mkdir -p "${pathToSubvolume_tmp}/etc/conf.d" && cp "/etc/conf.d/snapper" "${pathToSubvolume_tmp}/etc/conf.d/"

    # 'arrService' should alerady contain these services (for "real" system):
    # #systemctl enable snapper-timeline.timer                          # I do not want timeline snapshots; see 'snap-pac' # TODO: config option for creating timeline snapshot (too)
    #systemctl enable snapper-cleanup.timer                             # just to be sure, should also be enabled later when calling 'enable-service' # periodically clean up older snapshots
    #if [ "${bootloader}" = "grub" ]; then systemctl enable grub-btrfsd.service; fi  # just to be sure # Regenerate grub-btrfs.cfg
}

config-snapperRollback() { # called in a separate script after reboot
    # Parameter 1: path to snapperRollbackFolder (e.g. '/.btrfsroot')
    # Parameter 2: snapper snapshot subvolume (e.g. '@snapshots')
    # Parameter 3: snapperRollbackConfig file (e.g. '/etc/snapper-rollback.conf')

    local srf="${1}" # path to snapperRollbackFolder
    local sss="${2}" # snapper snapshot subvolume
    local srcf="${3}" # snapperRollbackConfig file

    echo "Download and install snapper-rollback (AUR)..."
    if [[ $(command -v snapper-rollback) ]]; then
        echo -e "\e[1;33m- 'snapper-rollback' is already installed \e[0m"
    else
        # echo "(Initial-)Password '${initialPassword}' can be used if asked"
        # su - USERID -c "curl -L -O https://aur.archlinux.org/cgit/aur.git/snapshot/snapper-rollback.tar.gz" # user not yet available in chroot
        curl -L -O https://aur.archlinux.org/cgit/aur.git/snapshot/snapper-rollback.tar.gz
        tar -xf snapper-rollback.tar.gz
        cd snapper-rollback || return
        makepkg --noconfirm --needed -sic
        cd .. || return
        rm -rf snapper-rollback snapper-rollback.tar.gz
    fi

    echo -e "Modify snapperRollbackConfig: set snapper snapshots subvolume name to configured subvolume name '${sss}'..."
    # currently set in config: @snapshots # which we used in the config (if not changed manually), so ther should be no change necessary
    sudo sed -i "s|@snapshots|${sss}|g" "${srcf}"

    echo -e "Modify snapperRollbackConfig: set configured snapperRollbackFolder to configured path '${srf}'..."
    # currently set in config: mountpoint = /btrfsroot
    sudo sed -i "s|/btrfsroot|${srf}|g" "${srcf}" # changing '/btrfsroot' to configured snapperRollbackFolder
}

# function 'config-shellConfUser-rollbackFunction()'
# only relevant if bootloader is systemd-boot und snapper-rollback (AUR) ist installed
# since this function also copies kernel and initramfs to efi partition
# For GRUB use standard 'sudo snapper-rollback <snapshotID>'
config-shellConfUser-rollbackFunction() {
    if [[ ! -e "${rollbackScriptSource}" ]]; then # http://mywiki.wooledge.org/BashFAQ/028
        echo >&2 "Please cd into the repo before running this script."
        return 1
    fi

    echo -e "\nCopy rollback script '${rollbackScriptName}' to '${rollbackScriptTargetPath}'..."
    sudo cp -vf "${rollbackScriptSource}" "${rollbackScriptTargetPath}/"
    sudo chmod 755 "${rollbackScriptTargetPath}/${rollbackScriptName}"

    echo -e "\nAdding an alias to shell conf to easily execute the script.\nCurrently only for: ${arrShellConfFileName[*]}.\nFor other shells / config must be done manually.\n"
    for shellConfFileName in "${arrShellConfFileName[@]}"; do
        echo "Adding alias to '${shellConfFileName}'..."
        shellConfFile=""
        shellConfFile="${HOME}/${shellConfFileName}"
        if [[ ! -e  "${shellConfFile}" ]]; then touch "${shellConfFile}"; fi
        if [[ -z $(grep "${rollbackScriptName}" "${shellConfFile}") ]]; then
            echo "${rollbackShellConfAlias}" >> "${shellConfFile}"
        else
            echo "Alias already in '${shellConfFileName}', nothing to do."
        fi
    done
}

modify-locales() {
    # Parameter 1: string with the items, seperated by space # Problem: items itsels partially have spaces inside itself (e.g. "en_US.UTF-8 UTF-8") -> no good dilimeter available
    # Parameter 2: path to the file in which the substitution will take place (should be "/etc/locale.gen")

    # uncomments needed locales in file ${2} (should be "/etc/locale.gen"):
    for locale in "${arrLocalegen[@]}"; do                   # not using Parameter 1: (see above), but directly the array specified in the config file
        sed -i "s|#${locale}|${locale}|g" "${2}"
    done
}

set-timezone() {
    # Parameter 1: timezone
    # Parameter 2: localtime file (should be /etc/localtime)

    echo "- set timezone (/etc/localtime)"
    ln -sf /usr/share/zoneinfo/"${1}" "${2}" # Set the time zone
    echo "- running hwclock to generate /etc/adjtime"
    hwclock --systohc
}

set-locales() {
    echo "- uncomment needed locales in '/etc/locale.gen'"
    modify-locales "${arrLocalegen[*]}" /etc/locale.gen             # uncomment needed locales in "/etc/locale.gen"
    echo "- generate the locales"
    locale-gen                                                      # Generate the locales
    echo "- creating the '/etc/locale.conf' file and setting the LANG variable"
    echo "LANG=${defaultLangPreferred}" >> /etc/locale.conf         # set the LANG variable   # localectl --no-convert set-keymap de-latin1
    echo "- make settings for the console keyboard layout persistent (/etc/vconsole.conf)"
    echo "KEYMAP=${consoleKeyboardLayout}" >> /etc/vconsole.conf    # make settings for the console keyboard layout persistent
}

config-network() {
    echo "- setting hostname (/etc/hostname)"
    echo "${myHostname}" >> /etc/hostname                     # Create / config the hostname file
    echo "- create + config '/etc/hosts'"
    {
        echo "127.0.0.1 localhost"
        echo "::1 localhost"
        echo "127.0.1.1 ${myHostname}.${myDomain} ${myHostname}"
    } >> /etc/hosts                                           # Create / config "/etc/hosts"

    echo "- installing network management software and enabling its systemd unit"
    # pacman -S --noconfirm --needed "${strListNetworkPkg}"           # installing network management software and enabling its systemd unit so that it starts at boot
    pacman -S --noconfirm --needed ${strListNetworkPkg}             # installing network management software and enabling its systemd unit so that it starts at boot
    systemctl enable NetworkManager
}

set-password() {
    # Parameter 1: userId

    echo "- changing password for '${1}' to configured initialPassword"
    # echo "${1}":password | chpasswd # set passwort for userId; script stops and waits for user input
    printf "${1}:%s" "${initialPassword}" | chpasswd # set passwort for userId, using ${initialPassword} from config   # or: sudo chpasswd <<<"${1}:${initialPassword}"

    if [ "${forceChangePassword}" = "true" ]; then passwd --expire "${1}"; echo "- forcing '${1}' to change password at next login"; fi     # forces the user to change password at next login
    # chage -l "${1}" # list password expiration and aging information for userId
}

create-userAccount() {
    echo "- creating account, setting configured initial password; if configured: forcing password change + adding user to group 'libvirt'"
    for userId in "${arrUserId[@]}"; do
        # useradd -m -U -s /bin/bash -p "${initialPassword}" "${userId}" # not the safe way, but password is in the config anyway... # create new user including: set initial passwort using ${initialPassword} from config
        useradd -m -U -s "/bin/${defaultShellUser}" "${userId}" # create new user

        set-password "${userId}"

        if [ "${virtualization}" = "true" ]; then usermod -aG libvirt "${userId}"; fi   # add user to libvirt group
    done
}

config-sudoUser() {
    echo "- config sudo user rights"
    for userId in "${arrSudoUser[@]}"; do
        # echo "${userId} ALL=(ALL) ALL" >> "/etc/sudoers.d/sudoUser"
        usermod -aG wheel "${userId}"   # if btrfs + snapper snapshot-folder '.snapshots' gets chown :wheel (in my ansible playbook, Repo 'ansible_workstation')
    done
    echo "%wheel ALL=(ALL:ALL) ALL" >> "/etc/sudoers.d/wheel"
}

install-grafics() {
if [ "${graficsCardInstalled}" = "true" ] && [ "${installDesktopEnvironment}" = "true" ]; then
        echo "- installing configured grafics packages"

        # lspci -k | grep -A 2 -E "(VGA|3D)" # lspci | grep -e VGA -e 3D
        mapfile -t arrGcdev < <(lspci | grep -E "(VGA|3D)")
        i=0
        for dev in "${arrGcdev[@]}"; do
            i=$((i+1))
            echo -e "\e[1mDevice \e[1;33m${i}\e[0m: ${dev}\n"
        done

        gcdevno=99999
        while [ "${gcdevno}" -gt "${i}" ] || [ "${gcdevno}" -lt 0 ] ; do
            read -rp "Enter valid Number of the grafics card device (0=skip): " gcdevno
        done

        if [ ! "${gcdevno}" -eq 0 ]; then
            gcdevno=$((gcdevno-1)) # array index count starts at 0
            strListGraficsCardPackage=$(get-graficsPackage "${arrGcdev[${gcdevno}]}")
        else
            strListGraficsCardPackage=""
        fi

        if [[ ! ${strListGraficsCardPackage} = "" ]]; then
            config-multilibrepo # For 32-bit application support the pacman 'multilib' repo hast to be enabled
            pacman -S --noconfirm --needed ${strListGraficsCardPackage};
        else
            echo -e "\e[0;33m'strListGraficsCardPackage' is empty, will not install gravics card packages.\e[0m"
        fi
        check-exitStatusLastCommand $?
    else
        echo "- NOT installing grafics card packages, 'graficsCardInstalled': '${graficsCardInstalled}', 'installDesktopEnvironment': '${installDesktopEnvironment}' (both must be 'true')"
    fi
}

get-graficsPackage() {
    # --- GRAFICS - need testing, check / config manually for your system ---
    # https://wiki.archlinux.org/title/AMDGPU
    # https://wiki.archlinux.org/title/Intel_graphics and https://wiki.archlinux.org/title/Hardware_video_acceleration
    # https://wiki.archlinux.org/title/NVIDIA
    # https://wiki.archlinux.org/title/NVIDIA_Optimus

    gcdev="${1}" # Parameter 1: lspci output for selected grafics card in 'install-grafics()'
    # gcdev="XXX" # overwriting Parameter 1 # set manually to "AMD" or "NVIDIA" or "Intel"; or s.th. else an set pacakges manually
    strListGraficsCardPackage=""
    strListGraficsCardPackage+="xorg-server xorg-xinit "

    case "${gcdev}" in
        *AMD*)
            strListGraficsCardPackage+="mesa "
            strListGraficsCardPackage+="xf86-video-amdgpu xf86-video-ati "
            strListGraficsCardPackage+="vulkan-radeon libva-mesa-driver " # mesa-vdpau
            strListGraficsCardPackage+="vulkan-icd-loader vulkan-headers vulkan-tools "
            strListGraficsCardPackage+="lib32-mesa lib32-vulkan-radeon lib32-libva-mesa-driver lib32-mesa-vdpau " # For 32-bit application support
            strListGraficsCardPackage+="lib32-vulkan-icd-loader "
        ;;

        *Intel*)
            strListGraficsCardPackage+="mesa "
            strListGraficsCardPackage+="xf86-video-intel "
            strListGraficsCardPackage+="vulkan-intel " # For Vulkan support (Broadwell and newer)
            strListGraficsCardPackage+="lib32-mesa lib32-vulkan-intel " # For 32-bit application support
            strListGraficsCardPackage+="intel-media-driver " # Hardware video acceleration (Broadwell and newer)
            # strListGraficsCardPackage+="libva-intel-driver "
        ;;

        *NVIDIA*)
            # strListGraficsCardPackage+="mesa libva-mesa-driver xf86-video-nouveau " # open-source nouveau driver
            # strListGraficsCardPackage+="nvidia-open nvidia-utils nvidia-settings dkms nvidia-open-dkms " # Turing (NV160/TUXXX) and newer
            strListGraficsCardPackage+="nvidia nvidia-utils nvidia-settings " # Maxwell (NV110/GMXXX) through Ada Lovelace (NV190/ADXXX)
            # 'nvidia-lts' for use with the linux-lts kernel; 'nvidia-dkms dkms' for all other kernels instead of 'nvidia'
            # strListGraficsCardPackage+="dkms nvidia-dkms "
            strListGraficsCardPackage+="lib32-nvidia-utils " # For 32-bit application support
            strListGraficsCardPackage+="vulkan-icd-loader lib32-vulkan-icd-loader " # add. features (hardware-accelerated rendering)
        ;;

        *)
            echo -e "\e[0;33mcase default: graficsCardManufacturer - not found in the list (-> not *AMD*, *NVIDIA* or *Intel*).\e[0m"
            echo -e "\e[0;33mNo grafics card installed or set variable 'strListGraficsCardPackage' in the script manually if necessary.\e[0m"
            strListGraficsCardPackage="" # for others: add packages manually
        ;;
    esac

    echo "${strListGraficsCardPackage}"
    return 0
}

config-multilibrepo() {
    local pacmanconf="/etc/pacman.conf"
    local searchString='\#\[multilib\]'
    local replaceString='[multilib]'
    local insertString='Include = /etc/pacman.d/mirrorlist'

    sed -i "/${searchString}/a ${insertString}" "${pacmanconf}"
    sed -i "s|^${searchString}|${replaceString}|g" "${pacmanconf}"

    pacman -Sy
}

install-bootloader() {
    if [ "${bootloader}" = "grub" ]; then
        echo "- installing ${bootloader}"
        pacman -S --needed --noconfirm "${bootloader}" # install grub
        # if [ "${filesystemType}" = "btrfs" ]; then pacman -S --noconfirm grub; else pacman -S --noconfirm grub; fi   # grub-btrfs
        echo -e "\n\e[0;35m- Configuring the boot loader \e[0m"
        config-bootloader-grub

        if [ "${bootMode}" = "Bios" ]; then             # Bios
            echo "- ... for Bios boot mode"
            grub-install --target=i386-pc "${device}"
        else                                            # Uefi
            echo "- ... for Uefi boot mode"
            pacman -S --needed --noconfirm efibootmgr
            grub-install --target=x86_64-efi --efi-directory="${pathEfi}" --bootloader-id="${bootloaderId}"
        fi

        echo "- creating Grub config file"
        grub-mkconfig -o "${pathGrubCfg}"               # grub: create config

    elif [ "${bootloader}" = "systemd-boot" ]; then
        echo -e "\e[0;35m- ${bootloader} - installing the UEFI boot manager \e[0m"
        bootctl --entry-token=machine-id --make-entry-directory=yes install

        config-bootloader-systemdboot
    fi
}

get-uuidRootPartition-chroot() {
    uuidRootPartition=""
    uuidRootPartition=$(lsblk -l -p -o Name,UUID | grep "${rootPartition}" | xargs | cut -d' ' -f2)
    # -l, --list: output in form of a list # -p, --paths: Print full device paths. # -o, --output <list>: Specify which output columns to print.
    # /dev/vda
    # /dev/vda1  ED26-00F7
    # /dev/vda2  7dc856b2-6b3a-41d4-9740-806f91b168aa
    #
    # uuidRootPartition=$(blkid | grep "${rootPartition}" | cut -d '"' -f 2) # chroot: $rootPartition read from file $fileRootPartition; see config file
    # Note: 'rootPartitionNo' not set in chroot, uses default value '0' from config (-> e.g. '/dev/vda0')
    # uuidRootPartition=$(blkid | grep "LABEL=\"${encryptionRootName}\"" | cut -d '"' -f 2) # /dev/vda3: UUID="32b092af-c623-4e01-853c-87725214980f" LABEL="ROOT" TYPE="crypto_LUKS" PARTUUID="d0ba9d2d-ce65-4408-ad9e-2baf4aa11f5a"
    # needs a label to be set in function 'format-partition'
    # uuidRootPartition=$(blkid | grep "crypto_LUKS" | cut -d '"' -f 2)   # no label, only root partition encrypted # /dev/vda3: UUID="b68f1d17-ff77-452a-9651-ce32ca2baddf" TYPE="crypto_LUKS" PARTUUID="56eae391-fa31-4f21-92b5-9b7d69eef604"

    # https://stackoverflow.com/questions/369758/how-to-trim-whitespace-from-a-bash-variable/3352015#3352015
    # remove leading whitespace characters
    uuidRootPartition="${uuidRootPartition#"${uuidRootPartition%%[![:space:]]*}"}"
    # remove trailing whitespace characters
    uuidRootPartition="${uuidRootPartition%"${uuidRootPartition##*[![:space:]]}"}"

    if [ -z "${uuidRootPartition}" ]; then
        blkid
        # echo -e "\e[0;31mUUID of root partition (NOT the mapper device !) could not be defined, please enter manually.\e[0m"
        read -r -p "Please enter UUID of root partition manually: " uuidRootPartition
    fi

    echo "${uuidRootPartition}"
}

config-bootloader-grub() {
    if [ "${encryption}" = "true" ]; then
        echo -e "\n\e[0;35m- Configuring ${bootloader} boot loader (encryption settings) \e[0m"
        # https://wiki.archlinux.org/title/Dm-crypt/Encrypting_an_entire_system#Configuring_the_boot_loader
        # In order to unlock the encrypted root partition at boot

        uuidRootPartition=""
        uuidRootPartition=$(get-uuidRootPartition-chroot)
        #uuidRootPartition=$(blkid | grep "${rootPartition}" | cut -d '"' -f 2) # chroot: $rootPartition read from file $fileRootPartition; see config file
        echo "uuidRootPartition: ${uuidRootPartition}"

        # GRUB_CMDLINE_LINUX_DEFAULT="loglevel=3 quiet"
        if [ "${keyfile}" = "true" ]; then
            sed -i "s|loglevel=3 quiet|loglevel=3 quiet cryptdevice=UUID=${uuidRootPartition}:${encryptionRootName} root=${encryptionRootPath} cryptkey=rootfs:${keyfilePath}|g" /etc/default/grub
        else
            sed -i "s|loglevel=3 quiet|loglevel=3 quiet cryptdevice=UUID=${uuidRootPartition}:${encryptionRootName} root=${encryptionRootPath}|g" /etc/default/grub
        fi

        # enable booting from LUKS encrypted devices:
        sed -i 's|#GRUB_ENABLE_CRYPTODISK=y|GRUB_ENABLE_CRYPTODISK=y|g' /etc/default/grub

        # sudo grub-mkconfig -o "$pathGrubCfg"   # not necessary anymore, will be done in function 'install-bootloader' after this function finishes
    else
        echo "   - no enryption config needed, encrytion: '${encryption}'"
    fi

    if [ "${zram}" = "true" ]; then
        # - https://wiki.archlinux.org/title/Zram#Using_zram-generator
        echo -e "\n\e[0;35m- Configuring ${bootloader} boot loader (zram settings) \e[0m"
        echo -e "'zwap' prevents 'zram' from being used effectively, will be disabled permanently via kernel parameter..." # 'zswap' is used by default in Arch Linux
        # zswapDisable_kernelOption='zswap.enabled=0' # already set in 'archinstall_autoBash.config'
        if [[ -z $(grep "${zswapDisable_kernelOption}" "${grubConfDefaultPath}") ]]; then # wenn kernel option noch nicht in ${grubConfDefaultPath}
            string=$(grep "GRUB_CMDLINE_LINUX_DEFAULT=" "${grubConfDefaultPath}") # grubConfDefaultPath set in config file
            tmpString="${string%?}" # remove last character (")
            tmpString+=" ${zswapDisable_kernelOption}\""
            sed -i "s|${string}|${tmpString}|g" "${grubConfDefaultPath}"
            echo -e "Recreate grub.cfg, including the new kernel option..."
            grub-mkconfig -o "${pathGrubCfg}"
        else
            echo -e "\e[1;33m- Kernel option to disable 'zswap' already in '${grubConfDefaultPath}' \e[0m"
            # head -n 8 -v "${grubConfDefaultPath}"
        fi
    else
        echo "   - no zram config needed, zram: '${zram}'"
    fi
}

config-bootloader-systemdboot() {
    echo -e "\n\e[0;35m- Configuring ${bootloader} boot loader \e[0m"

    machineid=$(cat /etc/machine-id)
    efiPartition_kernelInitramfsPath="${pathEfi}/${machineid}/" # e.g.: /efi/af36e2965f254d26a73f1eb3e6049a8c/
    systemdServiceUnitPath="/etc/systemd/system"
    # efistubUpdatePathFilename="efistub-update.path" # already defined in 'archinstall_autoBash.config' (for adding to services array)
    efistubUpdateServiceFilename="efistub-update.service"
    efistubUpdatePath_file="${systemdServiceUnitPath}/${efistubUpdatePathFilename}"
    efistubUpdateService_file="${systemdServiceUnitPath}/${efistubUpdateServiceFilename}"
    efiLoaderPath="${pathEfi}/loader"
    efiLoaderEntriesPath="${efiLoaderPath}/entries"
    efiLoaderConf_fileName="loader.conf"
    efiLoaderConf_file="${efiLoaderPath}/${efiLoaderConf_fileName}" # e.g.: /efi/loader/loader.conf

    echo "rootPartition: ${rootPartition}" # e.g.: /dev/vda2
    uuidRootPartition=""
    uuidRootPartition=$(get-uuidRootPartition-chroot)
    # uuidRootPartition=$(blkid | grep "${rootPartition}" | cut -d '"' -f 2) # chroot: $rootPartition read from file $fileRootPartition; see config file
    echo -e "uuidRootPartition: ${uuidRootPartition}\n"

    rootPartitionIsNvme="false"
    if [[ "${rootPartition}" == *nvme* ]]; then rootPartitionIsNvme="true"; fi

    # ### #####################################################################################
    # ### Create systemd unit files to copy kernel + intiramfs from /boot to /efi/<machinte-id>

    # --- create systemd unit file 'efistub-update.path'
    touch "${efistubUpdatePath_file}"
    efistubPathContentParts=()
    efistubPathContentParts=(
        "[Unit]"
        "Description=Copy EFISTUB Kernel to EFI system partition"
        ""
        "[Path]"
    )
    content=""
    for contentPart in "${efistubPathContentParts[@]}"; do
        content+="${contentPart}\n"
    done
    echo -e "${content}" > "${efistubUpdatePath_file}"

    content=""
    for kernel in "${arrKernel[@]}"; do # 'arrKernel' is defined in archinstall_autoBash.config; e.g.: ("linux" "linux-lts")
        content+="PathChanged=/boot/initramfs-${kernel}-fallback.img\n" # e.g. initramfs-linux-fallback.img
    done
    echo -e "${content}" >> "${efistubUpdatePath_file}"

    efistubPathContentParts=(
        "Unit=${efistubUpdateServiceFilename}"
        ""
        "[Install]"
        "WantedBy=multi-user.target"
        "WantedBy=system-update.target"
    )
    content=""
    for contentPart in "${efistubPathContentParts[@]}"; do
        content+="${contentPart}\n"
    done
    echo -e "${content}" >> "${efistubUpdatePath_file}"

    # --- create systemd unit file 'efistub-update.service'
    touch "${efistubUpdateService_file}"
    efistubServiceContentParts=()
    efistubServiceContentParts=(
        "[Unit]"
        "Description=Copy EFISTUB Kernel to EFI system partition"
        ""
        "[Service]"
        "Type=oneshot"
    )
    content=""
    for contentPart in "${efistubServiceContentParts[@]}"; do
        content+="${contentPart}\n"
    done
    echo -e "${content}" > "${efistubUpdateService_file}"

    content=""
    for kernel in "${arrKernel[@]}"; do
        content+="#${kernel}:\n"
        content+="ExecStart=/usr/bin/cp -af /boot/vmlinuz-${kernel} ${efiPartition_kernelInitramfsPath}\n"
        content+="ExecStart=/usr/bin/cp -af /boot/initramfs-${kernel}.img ${efiPartition_kernelInitramfsPath}\n"
        content+="ExecStart=/usr/bin/cp -af /boot/initramfs-${kernel}-fallback.img ${efiPartition_kernelInitramfsPath}\n"
    done
    echo -e "${content}" >> "${efistubUpdateService_file}"

    # Verify the syntax of the Systemd Unit files # TODO
    # systemd-analyze verify /etc/systemd/system/efistub-update.*

    # Initially we have to copy the kernel and initramfs manually to the efi partition:
    echo -e "\nInitial copy of kernel and initramfs to the efi partition via rsync"
    pacman -S --needed --noconfirm rsync # make sure rsync is available
    rsync -aPhEv --delete --exclude *ucode.img  /boot/* "${efiPartition_kernelInitramfsPath}"
    echo "- Content of /boot:"
    ls -lah "/boot"
    echo "- Content of ${efiPartition_kernelInitramfsPath}:"
    ls -lah "${efiPartition_kernelInitramfsPath}"


    # ### #########################
    # --- Loader and loader entries

    # --- Loader configuration
    # default entry alrady present (done by bootctl ... install); e.g.: default af36e2965f254d26a73f1eb3e6049a8c-*
    # - timeout:
    timeout=$(grep "timeout" "${efiLoaderConf_file}")
    timeoutNew="timeout 4" # set loader timeout to 4 seconds
    sed -i "s/${timeout}/${timeoutNew}/g" "${efiLoaderConf_file}"
    # - console-mode
    consolemode=$(grep "console-mode" "${efiLoaderConf_file}")
    consolemodeNew="console-mode max"
    sed -i "s/${consolemode}/${consolemodeNew}/g" "${efiLoaderConf_file}"
    # - editor
    echo "editor no" >> "${efiLoaderConf_file}"

    # --- Adding loaders
    for kernel in "${arrKernel[@]}"; do # 'arrKernel' is defined in archinstall_autoBash.config; e.g.: ("linux" "linux-lts")
        # - standard:
        loaderEntryFile=""
        content=""
        # Zeilen, die sich bei 'fallback' gegenüber 'standard' ändern: title und initrd
        titleLine="";  titleLine="title      Arch ${kernel}"
        initrdLine=""; initrdLine="initrd     /${machineid}/initramfs-${kernel}.img"
        titleLineFallback=""; titleLineFallback="title      Arch ${kernel} (fallback initramfs)"
        initrdLineFallback=""; initrdLineFallback="initrd     /${machineid}/initramfs-${kernel}-fallback.img"

        loaderEntryFile="${efiLoaderEntriesPath}/${machineid}-arch-${kernel}.conf"
        touch "${loaderEntryFile}"

        content+="${titleLine}\n"
        content+="machine-id ${machineid}\n"
        content+="linux      /${machineid}/vmlinuz-${kernel}\n"
        content+="${initrdLine}\n"
        if [ "${encryption}" = "true" ]; then
            # content+="options    rootflags=subvol=/@ rd.luks.name=1C2A3274-4C0B-4146-A5B7-EC8C5235E1FA=${encryptionRootName}"
            content+="options    rootflags=subvol=/@ rd.luks.name=${uuidRootPartition}=${encryptionRootName}"
            content+=" root=${encryptionRootPath} rw systemd.machine-id=${machineid}"
        else
            # content+="options    rootflags=subvol=/@ root=UUID=1C2A3274-4C0B-4146-A5B7-EC8C5235E1FA rw systemd.machine-id=${machineid}"
            content+="options    rootflags=subvol=/@ root=UUID=${uuidRootPartition} rw systemd.machine-id=${machineid}"
        fi
        content+=" nowatchdog" # https://wiki.archlinux.org/title/Improving_performance#Watchdogs # ok to set for non-critical home/desktop use case
        if [ "${rootPartitionIsNvme}" = "true" ]; then content+=" nvme_load=YES"; fi
        # ### ############################################
        # --- zram - set kernel parameter to disable zswap
        if [ "${zram}" = "true" ]; then content+=" ${zswapDisable_kernelOption}"; fi
        # ### ############################################
        content+="\n"
        echo -e "${content}" > "${loaderEntryFile}"

        # - fallback:
        content=""
        loaderEntryFileFallback="${efiLoaderEntriesPath}/${machineid}-arch-${kernel}-fallback.conf"
        # copy standard loaderEntryFile to loaderEntryFileFallback:
        cp -fv "${loaderEntryFile}" "${loaderEntryFileFallback}"
        touch "${loaderEntryFileFallback}"
        sed -i "s|${titleLine}|${titleLineFallback}|g" "${loaderEntryFileFallback}"
        sed -i "s|${initrdLine}|${initrdLineFallback}|g" "${loaderEntryFileFallback}"

        # - Check config:
        echo "Check systemd-boot config via 'bootctl --no-pager':"
        bootctl --no-pager # TODO: error handling # On success, 0 is returned, a non-zero failure code otherwise.
    done
}

# post-install - System on ESP (e.g. Archiso, Grml)
config-systemOnEsp() {
    iso="${1}" # Parameter 1 # e.g.: /home/userid/Downloads/archlinux-2024.11.01-x86_64.iso
    espSystemFolderName="${2}" # Parameter 2 # e.g.: "archiso"
    isoFileName="${3}" # Parameter 3 # e.g.: "grml64-full_2024.02.iso"

    espSystemFolder="${pathEfi}/EFI/${espSystemFolderName}" # e.g. /efi/EFI/archiso
    espLoaderEntriesConfFileName="${espSystemFolderName}.conf"
    espLoaderEntriesConfFile="${pathEfi}/loader/entries/${espLoaderEntriesConfFileName}"

    content=""
    freeDiskpace=0
    availableDiskpace=0
    # Archiso ~ 1000 MB # Grml (full) ~ 890 MB # Grml (small) ~ 500 MB ? # SystemRescue ~ 910 MB, SystemRescue iso ~1200MB
    requiredDiskspaceSystemOnESP=1000 # size in MB # default value # may be changed when differentiating between the systems

    # set values for loader entry
    title="${espSystemFolderName} (live system)"
    case "${system}" in
        archiso)
            linux="/EFI/${espSystemFolderName}/boot/x86_64/vmlinuz-linux"
            initrd="/EFI/${espSystemFolderName}/boot/x86_64/initramfs-linux.img"
            options="options archisobasedir=/EFI/${espSystemFolderName} archisosearchfilename=/EFI/${espSystemFolderName}/boot/x86_64/vmlinuz-linux copytoram"

            archEntry="${espLoaderEntriesConfFile}" # remember for sysresccd, to get 'linux' and 'initramfs' lines from the file
        ;;
        grml)
            linux="/EFI/${espSystemFolderName}/vmlinuz"
            initrd="/EFI/${espSystemFolderName}/initrd.img"
            options="options apm=power-off boot=live live-media-path=/EFI/${espSystemFolderName}/ nomce net.ifnames=0 copytoram"
        ;;
        sysresccd)
            efiPartition=$(lsblk -l -p -o NAME,MOUNTPOINTS | grep "${pathEfi}" | xargs | cut -d' ' -f1) # e.g.: /dev/vda1

            if [ "$(sudo ls "${pathEfi}/EFI/archiso")" ]; then # we can us kernel and initramfs from archiso to start and then just load iso for sysresccd
                linux=$(sudo grep '^linux' "${archEntry}" | cut -d' ' -f2) # e.g.: linux=$(sudo grep '^linux' /efi/loader/entries/archiso.conf | cut -d' ' -f2)
                initrd=$(sudo grep '^initrd' "${archEntry}" | cut -d' ' -f2) # cut -> not prededed by 'linux'  oder 'initrd'
                requiredDiskspaceSystemOnESP=1200
                echo "- Can use kernel and initramfs from archiso"
                canUseArchiso="true"
            else
                linux="/EFI/${espSystemFolderName}/boot/x86_64/vmlinuz"
                initrd="/EFI/${espSystemFolderName}/boot/x86_64/sysresccd.img"
                requiredDiskspaceSystemOnESP=2100
                echo "- Can NOT use kernel and initramfs from archiso"
                canUseArchiso="false"
            fi
            options="img_dev=${efiPartition} img_loop=EFI/${espSystemFolderName}/${isoFileName} archisobasedir=${espSystemFolderName} copytoram"
        ;;
        *)
            echo -e "\e[1;33m'${espSystemFolderName}' - config-systemOnEsp - no config available yet.\e[0m"
            return 0
        ;;
    esac

    # check available disk space an create espSystemFolder:
    if [[ -n $(sudo ls "${espSystemFolder}") ]]; then # if folder not exists thows error message, but continues with else (coud add 2>/dev/null)
        echo -e "\e[1;33mFolder '${espSystemFolder}' already exists. Skipping 'config-systemOnEsp'\e[0m"
        return 0
    else
        freeDiskpace=$(sudo df --output=avail "${pathEfi}" | tail -n+2 | xargs)
        freeDiskpace=$(("${freeDiskpace}" / 1024)) # size in MB
        availableDiskpace=$(("${freeDiskpace}"-"${reserveDiskspaceESP}"))
        if [ "${availableDiskpace}" -lt "${requiredDiskspaceSystemOnESP}" ]; then
            echo -e "\e[0;31mNot enough disk space. Skipping 'config-systemOnEsp' !\e[0m"
            echo -e "\e[0;31m- availableDiskpace (reduced by reserve): ${availableDiskpace}, requiredDiskspaceSystemOnESP: ${requiredDiskspaceSystemOnESP}\e[0m"
            return 1
        else
            echo -e "- Creating folder '${espSystemFolder}'..."
            sudo mkdir -p "${espSystemFolder}"
        fi
    fi

    # copy files to espSystemFolder (kernel, initramfs, squashed image (grml)):
    case "${system}" in
        archiso)
            sudo bsdtar -v -x --no-same-permissions --strip-components 1 -f "${iso}" -C "${espSystemFolder}" arch
        ;;
        grml)
            grmlFlavour=$(echo "${isoFileName}" | cut -d'_' -f1) # e.g.: grml64-full
            # grmlFlavourBootFolder=$(echo "${grmlFlavour}" | sed 's/-//g') # e.g.: grml64full
            grmlFlavourBootFolder="${grmlFlavour/-/}" # e.g.: grml64full
            sudo mount "${iso}" /mnt
            sudo cp -vf "/mnt/boot/${grmlFlavourBootFolder}/vmlinuz" "${espSystemFolder}"
            sudo cp -vf "/mnt/boot/${grmlFlavourBootFolder}/initrd.img" "${espSystemFolder}"
            sudo cp -vf "/mnt/live/${grmlFlavour}/${grmlFlavour}.squashfs" "${espSystemFolder}"
        ;;
        sysresccd)
            if [ "${canUseArchiso}" = "false" ]; then
                # e.g.: sudo bsdtar -v -x --no-same-permissions --strip-components 1 -f ~/Downloads/systemrescue-11.02-amd64.iso -C /efi/EFI/sysresccd sysresccd
                sudo bsdtar -v -x --no-same-permissions --strip-components 1 -f "${iso}" -C "${espSystemFolder}" "${espSystemFolderName}"
            fi
            sudo cp -vf "${iso}" "${espSystemFolder}/"
        ;;
        *)
            echo -e "\e[1;33m${system}' - config-systemOnEsp - no config available yet.\e[0m"
            return
        ;;
    esac

    # create loader entry:
    sudo touch "${espLoaderEntriesConfFile}"
    content+="title ${title}\n"
    content+="linux ${linux}\n"
    content+="initrd ${initrd}\n"
    content+="options ${options}\n"
    echo -e "${content}" | sudo tee "${espLoaderEntriesConfFile}"

    # - Check config:
    echo "- Check systemd-boot config via 'bootctl --no-pager':"
    sudo bootctl --no-pager # TODO: error handling # On success, 0 is returned, a non-zero failure code otherwise.
}

config-mkinitcpio() {
    # modify MODULES:
    if [ "${filesystemType}" = "btrfs" ]; then
        sed -i 's/MODULES=()/MODULES=(btrfs)/g' "${pathToMkinitcpioConf}"
    fi

    # modify FILES (if encryption + keyfile + GRUB bootloader):
    if [ "${encryption}" = "true" ] && [ "${keyfile}" = "true" ] && [ "${bootloader}" = "grub" ]; then
        sed -i "s|FILES=()|FILES=(${keyfilePath})|g" "${pathToMkinitcpioConf}"
    fi

    # modify HOOKS:
    # HOOKS=(base udev autodetect microcode modconf kms keyboard keymap consolefont block filesystems fsck) # default
    hooksLine=""; hooksLine=$(grep -e '^HOOKS=' "${pathToMkinitcpioConf}")

    if [ "${bootloader}" = "grub" ]; then
        if [ "${encryption}" = "true" ]; then
            hooksLineNew="${hooksLine/filesystems/encrypt filesystems}" # replace 'filesystems' with 'encrypt filesystems'
            sed -i "s/^${hooksLine}/${hooksLineNew}/g" "${pathToMkinitcpioConf}" # replace old hooksLine with hooksLineNew in the file
        fi
    elif [ "${bootloader}" = "systemd-boot" ]; then
        hooksLineNew="${hooksLine/udev/systemd}"
        hooksLineNew="${hooksLineNew/keymap consolefont/sd-vconsole}"

        if [ "${encryption}" = "true" ]; then
            hooksLineNew="${hooksLineNew/filesystems/sd-encrypt filesystems}"
        fi

        sed -i "s/^${hooksLine}/${hooksLineNew}/g" "${pathToMkinitcpioConf}" # replace old hooksLine with hooksLineNew in the file
    fi
}

install-additionalPackages() {
    echo "- installing configured packages: standard, print, firewall, conflicting"
    pacman -S --noconfirm --needed ${strListAdditionalPkg}

    pacman -S --noconfirm --needed ${strListAdditionalPkg_print}
    pacman -S --noconfirm --needed ${strListAdditionalPkg_firewall}
    #pacman -S --noconfirm ${strListAdditionalPkg_PowerMgmt}  # TODO: query if corresponding variable is set -> install
    yes | pacman -S ${strListAdditionalPkg_conflicting}       # install packages with known conflicts an confirm prompt-question with yes

    if [ "${virtualization}" = "true" ]; then
        # TODO: check cpu for virtualization support
        # TODO: nested virtualization

        echo "- installing additional packages for virtualization"
        pacman -S --noconfirm --needed ${strListAdditionalPkg_VM}
        # TODO: config '/etc/libvirt/libvirtd.conf' # e.g. set: unix_sock_group = "libvirt" # unix_sock_rw_perms = "0770"

        # pacmman -S -noconfirm --needed spice-vdagent   # TODO: only if the machine is a virtual machine: clipboard sharing Guest<->Host
    fi

    # pacman -S --noconfirm --needed "${strListAdditionalPkg_zsh}"   # TODO
    # echo "${zshSyntaxConf}" >> $userdir/.zshrc                     # TODO
}

enable-service() {
    echo "- enabling services ..."
    for service in "${arrService[@]}"; do
        systemctl enable "${service}"
    done
}

install-DesktopEnvironment() {
    if [ "${installDesktopEnvironment}" = "true" ]; then
        case "${desktopEnvironmentName}" in
            "Gnome")
                echo "- installing packages for Gnome + enabling gdm"
                pacman -S --noconfirm --needed ${strListBasePkg_Gnome}
                #pacman -S --noconfirm --needed gnome-extra

                systemctl enable gdm
            ;;

            *)
                echo -e "\e[0;33mdefault case, function 'install-DesktopEnvironment' - '${desktopEnvironmentName}' not available\e[0m"   # TOOD: add more desktop environments
            ;;
        esac

        echo "- installing additional packages"
        pacman -S --noconfirm --needed ${strListDesktopEnvPgk}
    else
        echo "No DesktopEnvironment will be installed because variable 'installDesktopEnvironment' is set to 'false'"
    fi
}


newFunction() {
    echo "# TODO: implement function '${FUNCNAME}'"
}
