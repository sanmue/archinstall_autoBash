#!/usr/bin/env bash

set -x   # enable debug mode

# ----------------------------------------------------------------
# Name                 archinstall_autoBash.sh
# Description          simple rudimentary bash script to automate my arch linux installation
# Prerequisites        bash >= version 4
# Author               Sandro ( sandro{at}universalaccount.de )
# Company              private
# Licence              GPLv3
# ----------------------------------------------------------------


# ------------------
# Config / Variables
# ------------------

# --- Specify the config variables according to your needs:
initialPassword='Start1234'         # for all users, including root # Change here now (optional) and later after install+reboot / at next login (forced)
arrUserId=("sandro" "r2d2" "tron" "data")   # specify UserID(s) of the account(s) to be created (more than 1: space separated list)
arrSudoUser=("sandro")              # specify users who will have sudo privilege to execute any command (more than 1: space separated list)

consoleKeyboardLayout="de-latin1"   # console keyboard layout:  temporary for current session + permanent (>> /etc/vconsole.conf)   # ls /usr/share/kbd/keymaps/**/*.map.gz
terminalFont="ter-122b"             # terminal font (temporary for current session)   # ls /usr/share/kbd/consolefonts/ | grep ter | less
timezone="Europe/Berlin"            # timezone   # timedatectl list-timezones

partitionDisk="true"                # "true" or "false" # if the disk should be partitioned # only simple partitioning supported: https://wiki.archlinux.org/title/Partitioning#Example_layouts 
                                    # set value to "false" if disk is already partitioned (perhaps with a more complex setup)
formatPartition="true"              # "true" or "false" # if Partitions should be formatted
                                    # set value to "false" if disk is already partitioned an formated (perhaps with a more complex setup); set according to variable 'partitionDisk'
eraseDisk="false"                   # "true" or "false" # erase complete disk with random bytes via 'dd'-command (could take some time)
mountPartition="true"               # "true" or "false" # if the partitions generated by the script should be mounted   # set according to variable 'formatPartition' or if your layout matches the layout-example
blockSize="512"                     # default: 512 bytes) # blocksize parameter for dd command; if eraseDisk="true"
deviceName="vda"                    # device name (eg. vda, sda, nvme0n1, ...); ! NOT a partition, e.g. vda1 !   # lsblk | grep --extended-regexp --invert-match 'rom|loop|airoot'
bootMode="Bios"                     # "Bios" or "Uefi" (!starting capital letter!) # boot mode   # check the UEFI bitness: cat /sys/firmware/efi/fw_platform_size
partitionType="gpt"                 # "gpt" (Bios or Uefi boot mode) or "mbr" (only Bios boot mode) # Partition type
efiPartitionSize="1500"             # size in MB # only for UEFI boot mode: specify size of EFI-Partition in MB; should be min. 300 MB
swapPartitionSize="2000"            # size in MB # specify the size of the swap partition
filesystemType="btrfs"              # filesystem type for root partition (e.g. "btrfs", "ext4") (and home partition)   # man mkfs.<filesystemType>

cpuManufacturer="XXX"               # "amd" or "intel" supported in this script; others: specify manually in variable strListCpuPgk further below

# grafics not testet - check and correct manually further below
graficsCardInstalled="false"        # "true" or "false" # if you have installed a Grafics Card, set value to "true"; set to "false" if not or if you want to do it later yourself
graficsCardManufacturer="amd"       # "amd" or "nvidia" or "intel" considered in this script; for others: you must manually set varialbe "strListGraficsCardPkg" further below 

arrLocalegen=("en_US.UTF-8 UTF-8" "de_DE.UTF-8 UTF-8" "de_DE.UTF-8 ISO-8859-1" "de_DE@euro ISO-8859-15")   # /etc/locale.gen # one or more locales to be uncommented in /etc/locale.gen
defaultLang="${arrLocalegen[1]}"    # default language will be set to the firts element in the array "arrLocalegen"

myHostname="archmachine"            # specify hostname for the machine
myDomain="home.arpa"                # specify domain

strListAdditionalPkg="base-devel linux-headers reflector acpi acpid acpi_call alsa-utils avahi bash-completion bluez bluez-utils dialog dnsutils dosfstools dnsmasq flatpak gvfs gvfs-smb inetutils ipset mtools nfs-utils nss-mdns openbsd-netcat openssh os-prober pulseaudio rsync sof-firmware terminus-font vde2 xdg-user-dirs xdg-utils"
strListAdditionalPkg_print="cups hplip"           # Printing support
strListAdditionalPkg_firewall="firewalld"         # Firewall (ufw, ... not supported by the script yet)
#strListAdditionalPkg_PowerMgmt="tlp"             # Linux Advanced Power Management # not needed if installing a desktop environment or a virtual machine (VM)
strListAdditionalPkg_conflicting="iptables-nft"   # iptables-nft (or iptables) needed for VM # iptables-nft and iptables (installed) are in conflict. Script Will confirm to remove iptables.
virtualization="false"                             # "true" or "false" # if virtualization should be installed (and configured)
strListAdditionalPkg_VM="qemu-full virt-manager virt-viewer bridge-utils dnsmasq dmidecode ebtables edk2-ovmf iptables-nft libguestfs libvirt openbsd-netcat swtpm vde2 virt-install" # virtualization # iptables-nft should already be installed
#strListAdditionalPkg_zsh="zsh zsh-autosuggestions zsh-completions zsh-history-substring-search zsh-syntax-highlighting"   # zsh + some plugins
#zshConfSyntax="source /usr/share/zsh/plugins/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh"   # To activate zsh-syntax-highlighting, add the following line at the end of `~/.zshrc`

# --- Do not change until you are sure:
minBashVersion=4                    # min. required bash version for this script

device="/dev/${deviceName}"         # disk to be formated, e.g. /dev/vda (NOT a partition like /dev/vda1)
partitionLabelRoot="root"           # label for root partition
partitionLabelHome="home"           # label for home partition
partitionLabelEfi="EFI"             # label for EFI partition
fileSystemTypeEfi="fat"             # file system type for efi partition
fatSize="32"                        # or "12","16","32" # type of file allocation tables used for FAT-Filesystem (Uefi: format option for efi-partition)   # man mkfs.fat
mountOptionDefault=""               # Standard mount option; empty: let mount command go for it 
mountOptionBtrfs="defaults,noatime,compress=zstd,space_cache=v2"  # mount options if formatted with btrfs filesystem
initialLsblk=$(lsblk --noheadings | grep --extended-regexp --invert-match 'rom|loop|airoot')      # list of available block devices at script start, except for type 'rom' or 'loop' or 'airoot'
efiPartitionNo=0                    # correct value will be set in function 'format-partition'    # Partition number, eg. "1" for /dev/vda1, "2" for /dev/vda2, ...
swapPartitionNo=0                   # correct value will be set in function 'format-partition'    # Partition number, eg. "1" for /dev/vda1, "2" for /dev/vda2, ...
rootPartitionNo=0                   # correct value will be set in function 'format-partition'    # Partition number, eg. "1" for /dev/vda1, "2" for /dev/vda2, ...
efiDir="efi"                        # boot/efi is deprecated # option for grub-install (Uefi)

# !!! strListPacstrapPackage: pactrap -K ... funktioniert nicht mit Variable als Parameter -> 'hart' eingetragen, s.u.
strListPacstrapPackage="base base-devel linux linux-firmware linux-headers man-db man-pages texinfo vim git"   # essential packages for initial install
case "${cpuManufacturer}" in        # https://wiki.archlinux.org/title/Microcode
    "amd")
        strListCpuPgk="amd-ucode"
        strListPacstrapPackage="${strListPacstrapPackage} ${strListCpuPgk}"
    ;;

    "intel")
        strListCpuPgk="intel-ucode"
        strListPacstrapPackage="${strListPacstrapPackage} ${strListCpuPgk}"
    ;;

    *)
        echo -e "\e[0;33mcase default: cpuManufacturer - Variable 'strListCpuPgk' must be set manually.\e[39m"
        #strListCpuPgk=""
        #strListPacstrapPackage="${strListPacstrapPackage} ${strListCpuPgk}"
    ;;
esac

# --- Not tested, check and specify manually ---
# lspci -k | grep -A 2 -E "(VGA|3D)"
if [ "${graficsCardInstalled}" = "true" ]; then 
    case "${graficsCardManufacturer}" in
        "amd")
            # https://wiki.archlinux.org/title/AMDGPU
            strListGraficsCardPackage="xf86-video-amdgpu"                     #TODO: test # X.org amdgpu video driver 
            #strListGraficsCardPackage="vulkan-radeon"                        #TODO: test # For Vulkan support # Test with only vulkan-radeon first
        ;;

        "nvidia")
            # https://wiki.archlinux.org/title/NVIDIA
            strListGraficsCardPackage="nvidia nvidia-utils nvidia-settings"   #TODO: test # 'nvidia' for use with the linux kernel
            # 'nvidia-lts' for use with the linux-lts kernel   # 'nvidia-dkms' for all other kernels
        ;;

        "intel")
            # https://wiki.archlinux.org/title/Intel_graphics
            strListGraficsCardPackage="xf86-video-intel"                      #TODO: test
            #strListGraficsCardPackage="vulkan-intel"                         #TODO: test # For Vulkan support (Haswell and newer)   
        ;;

        *)
            echo -e "\e[0;33mcase default: graficsCardManufacturer - Variable 'strListGraficsCardPackage' must be set manually.\e[39m"
            strListGraficsCardPackage=""
        ;;
    esac
fi

bootloader="grub"                   # Bootloader # only GRUB supported at the moment; prefered for btrfs + snapper (or timeshift, ...)
bootloaderId="GRUB"                 # or "archlinux", ... # bootloader ID


# --- Do not change / not supported by the script yet:
#rootPartitionSize="25000"           #TODO: size in MB for the root partition   # V1: only set root partition size, home partition gets the remaining space
#homePartition="false"               #TODO: "/home" folder on a seperate partition (on the same disk as root partition)
#homePartitionSize="25000"           #TODO: size in MB for the root partition   # V2: only set home partition size, root partition gets the remaining space
#homePartitionNo=0                   #TODO: value will be overwritten/set in function format-partition   # Partition number, eg. "1" for /dev/vda1, "2" for /dev/vda2, ...
#swapPartition="true"                #TODO: # currently a separate swap partition will be created   # if a separate swap partition should be created # btrfs + snapper probably better "true"
#swapFile="false"                    #TODO: "true" or "false" # if a swap file should be created

# ---------
# Functions
# ---------
function check-bashVersion() {
    # Parameter 1: min. required (major) bash version

    if [ "${BASH_VERSINFO[0]}" -lt "${1}" ]; then
        echo -e "Current bash version: ${BASH_VERSINFO[0]}\nMin. required version: '${1}'\nexit, sorry"
        exit 1
    fi
}

function check-devicePath() {
    # Parameter 1: device path (e.g. /dev/vda)

    echo "Checking if '${1}' ist available"
    if [ ! -b "${1}" ]; then   # if ${device} ("file") not available
        echo -e "\e[0;33m!!! '${1}' not found !!!\e[39m \nExit the script"
        exit 1
    fi
}

function erase-device() {
    # Parameter 1: device path (e.g. /dev/vda)
    # Parameter 2: blocksize

    if [ "${eraseDisk}" = "true" ]; then   # Erase (overwrite) device
        echo -e "\e[0;33m!!! Erasing '${1}', will take some time... !!!\e[39m"
        echo "Press Enter to continue or '<CTRL> + <C>' to cancel"   # only for testing
        read -r                                                      # only for testing
        dd if=/dev/urandom of="${1}" bs="${2}" status=progress       #TODO: test # erase device by copying random bytes to the hole disk
    fi
}

function partition-disk() {
    # Parameter 1: bootmode (Bios or Uefi)
    # Parameter 2: partition type (gpt or mbr) (Uefi: only gpt)
    # Parameter 3: device path (e.g. /dev/vda)
    # Parameter 4: size of swap partition
    # Parameter 5: size of EFI partition (only when Uefi bootmode)

    if [ "${1}" = "Bios" ]; then
        partition-diskBios "${2}" "${3}" "${4}"
    else
        partition-diskUefi "${3}" "${4}" "${5}"
    fi
}

function partition-diskBios() {
    # Parameter 1: partition type (gpt or mbr)
    # Parameter 2: device path (e.g. /dev/vda)
    # Parameter 3: size of swap partition

    if [ "$1" = "gpt" ]; then
        (
        echo g   # --- create a new empty GPT partition table ---
        
        echo n   # --- add a new partition: Small 1 MB partition --
        echo     # accept default value (Partition No: 1)
        echo     # accept default value (Start first sector)
        echo +1M # partition size
        echo t   # change partition type
        echo     # accept default value (Partition No: 1)
        echo 4   # Type: Bios boot

        echo n   # --- add a new partition: Swap ---
        echo     # accept default value (Partition No: 2)
        echo     # accept default value (Start of first sector)
        echo +"${3}"M # partition size
        echo t   # change partition type
        echo     # accept default value (Partition No: 2)
        echo 19  # Type: Linux swap

        echo n   # --- add a new partition: root ---
        echo     # accept default value (Partition No: 3)
        echo     # accept default value (start of first sector)
        echo     # accept default value (end of last sector (Remainder of device))

        echo w   # Write changes
        ) | sudo fdisk "${2}" 1>/dev/null
    else
        # partition type "mbr"
        (
        echo o   # --- create a new empty MBR (DOS) partition table ---
        
        echo n   # --- add a new partition: Swap ---
        echo p   # primary (partition type)
        echo     # accept default value (Partition No: 1)
        echo     # accept default value (Start of first sector)
        echo +"${3}"M # partition size
        echo t   # change partition type
        echo     # accept default value (Partition No: 1)
        echo 82  # Type: Linux swap / Solaris

        echo n   # --- add a new partition: root ---
        echo p   # primary (partition type)
        echo     # accept default value (Partition No: 2)
        echo     # accept default value (start of first sector)
        echo -1M # leaves small unallocated space of 1MB at the end of the disk

        echo w   # Write changes
        ) | sudo fdisk "${2}" 1>/dev/null
    fi
}

function partition-diskUefi() {
    # Parameter 1: device path (e.g. /dev/vda)
    # Parameter 2: size of swap partition
    # Parameter 3: size of EFI partition

    (
    echo g   # --- create a new empty GPT partition table ---

    echo n   # --- add a new partition: EFI boot partition ---
    echo     # accept default value (Partition No: 1)
    echo     # accept default value (Start first sector)
    echo +"${3}"M # partition size
    echo t   # change partition type
    echo     # accept default value (Partition No: 1)
    echo 1   # Type: EFI System

    echo n   # --- add a new partition: Swap ---
    echo     # accept default value (Partition No: 2)
    echo     # accept default value (Start of first sector)
    echo +"${2}"M # partition size
    echo t   # change partition type
    echo     # accept default value (Partition No: 2)
    echo 19  # Type: Linux swap

    echo n   # --- add a new partition: root ---
    echo     # accept default value (Partition No: 3)
    echo     # accept default value (start of first sector)
    echo     # accept default value (end of last sector (Remainder of device))

    echo w   # Write changes
    ) | sudo fdisk "${1}" 1>/dev/null
}

function format-partition() {
    # Parameter 1: device
    # Parameter 2: bootMode
    # Parameter 3: partitionType
    # Parameter 4: filesystemType
    # Parameter 5: fileSystemTypeEfi
    # Parameter 6: fatSize
    # Parameter 7: partitionLabelRoot
    # Parameter 8: partitionLabelEfi
    # Parameter 9: partitionLabelHome

    if [ "${2}" = "Bios" ] && [ "${3}" = "gpt" ]; then            # Bios + gpt
        # Partition No 1: empty
        swapPartitionNo=2
        rootPartitionNo=3

        mkswap "${1}${swapPartitionNo}"                           # make swap-partition
        mkfs."${4}" -f -L "${7}" "${1}${rootPartitionNo}"         # format root-partition

    elif [ "${2}" = "Bios" ] && [ "${3}" = "mbr" ]; then          # Bios + mbr
        swapPartitionNo=1
        rootPartitionNo=2

        mkswap "${1}${swapPartitionNo}"                           # make swap-partition
        mkfs."${4}" -f -L "${7}" "${1}${rootPartitionNo}"         # format root-partition

    else                                                          # Uefi + gpt
        efiPartitionNo=1
        swapPartitionNo=2
        rootPartitionNo=3

        mkfs."${5}" -F "${6}" -n "${8}" "${1}${efiPartitionNo}"   # format efi-partition
        mkswap "${1}${swapPartitionNo}"                           # make swap-partition
        mkfs."${4}" -f -L "${7}" "${1}${rootPartitionNo}"         # format root-partition
    fi
}

function mount-partition() {
    # Parameter 1: device
    # Parameter 2: bootMode
    # Parameter 3: filesystemType
    # Parameter 4: efiPartitionNo
    # Parameter 5: swapPartitionNo
    # Parameter 6: rootPartitionNo

    #echo -e "efiPartitionNo ${4} \nswapPartitionNo ${5} \nrootPartitionNo ${6}"   # only for test

    case "${3}" in   # set mount option
        "btrfs")
            mountOption="-o ${mountOptionBtrfs}"
            #mountOption="-o ${mountOptionBtrfs} -t ${3}"
        ;;

        *)
            if [ "${mountOptionDefault}" = "" ]; then   # let mount command go for it
                mountOption="${mountOptionDefault}"
            else
                mountOption="-o ${mountOptionDefault}"
            fi
        ;;
    esac

    # mount partitions:
    if [ "${2}" = "Uefi" ]; then
        mkdir /mnt/"${efiDir}"
        mount "${1}${4}" /mnt/"${efiDir}"    # efi-partition
    fi

    #mount "${mountOption}" "${1}${6}" /mnt   # root-partition
    mount "${1}${6}" /mnt                    # root-partition
    swapon "${1}${5}"                        # swap-partition
}

function uncomment-locales() {
    # Parameter 1: array with locales to uncomment
    # Parameter 2: path to the file in which the substitution will take place (e.g. "/etc/locale.gen")

    #TODO: validate Parameter 2

    for locale in "${1[@]}"; do                  # uncomment needed locales
        sed -i "s|#${locale}|${locale}|g" "${2}" 
    done
}

function newFunction() {
    echo "#TODO: implement function '${FUNCNAME}'"
}


# ----
# main
# ----
check-bashVersion "${minBashVersion}"  # check if prerequisite bash version is fulfilled

# --- Pre-installation ---
loadkeys "${consoleKeyboardLayout}"    # set console keyboard layout  (temporary for current session)
setfont "${terminalFont}"              # set terminal font (temporary for current session)

#TODO Verify the boot mode
#TODO Check internet connection

timedatectl set-timezone "${timezone}" # set timezone
#timedatectl status                     # show timezone settings

#TODO Check for existing partition(s) (would be overwritten via function "partition-disk")

echo "${initialLsblk}"              # show available block devices at script start, except type 'rom' or 'loop' or 'airoot'
check-devicePath "${device}"           # check if given device path is valid

#TODO: function "partition-disk"
if [ ${partitionDisk} = "true" ]; then        # if partitioning the device should be executed
    echo -e "\e[0;33mPartitioning device '${device}'...\e[39m"

    erase-device "${device}" "${blockSize}"   # executed only if eraseDisk="true" is set # the device will be erased (overwritten via dd command)
    partition-disk "${bootMode}" "${partitionType}" "${device}" "${swapPartitionSize}" "${efiPartitionSize}"   # partition the device
    lsblk | grep --extended-regexp --invert-match 'rom|loop|airoot'   # show result   # lsblk | grep "${deviceName}"
fi

if [ ${formatPartition} = "true" ]; then      # if formating the partitions should be executed
    echo -e "\e[0;33mFormating the partitions...\e[39m"
    format-partition "${device}" "${bootMode}" "${partitionType}" "${filesystemType}" "${fileSystemTypeEfi}" "${fatSize}" "${partitionLabelRoot}" "${partitionLabelEfi}" "${partitionLabelHome}"
fi

if [ ${mountPartition} = "true" ]; then       # if mounting of the partitions should be done
    echo -e "\e[0;33mMounting the partitions...\e[39m"
    mount-partition "${device}" "${bootMode}" "${filesystemType}" "${efiPartitionNo}" "${swapPartitionNo}" "${rootPartitionNo}"
fi

# --- Installation ---
#TODO: custom config pacman / reflector
#pacstrap -K /mnt "${strListPacstrapPackage}"  # Install essential packages to "/mnt" (new root partition is mounted to /mnt)
pacstrap -K /mnt base base-devel linux linux-firmware linux-headers man-db man-pages texinfo vim git


# --- TEST
lastCmdSuccessful=$?
if [ $lastCmdSuccessful -eq 0 ]; then
    echo "Last Cmd was successful"
else
    echo "Last Cmd was NOT successful, exit"
    exit 1
fi
# --- TEST


# --- Configure the system ---
genfstab -U /mnt >> /mnt/etc/fstab                       # crate fstab

arch-chroot /mnt                                         # chroot /mnt
#cat << EOF | arch-chroot /mnt
ln -sf /usr/share/zoneinfo/"${timezone}" /etc/localtime   # Set the time zone
hwclock --systohc                                         # Run hwclock(8) to generate /etc/adjtime

#TODO: function "set-locales"
uncomment-locales "${arrLocalegen[@]}" "/etc/locale.gen"  # uncomment needed locales in "/etc/locale.gen"
locale-gen                                                # Generate the locales
echo "${defaultLang}" >> /etc/locale.conf                 # set the LANG variable
echo "KEYMAP=${consoleKeyboardLayout}" >> /etc/vconsole.conf   # make settings for the console keyboard layout persistent
#TODO: optional: further customization of '/etc/locale.conf' (e.g. LC_ADDRESS, LC_IDENTIFICATION, ... for other locale than defaultLang)

#TODO: function "config-network"
echo "${myHostname}" >> /etc/hostname                     # Create / config the hostname file
{
    echo "127.0.0.1 localhost"
    echo "::1 localhost"
    echo "127.0.1.1 ${myHostname}.${myDomain} ${myHostname}"
} >> /etc/hosts                                           # Create / config "/etc/hosts"
pacman -S --noconfirm networkmanager network-manager-applet wpa_supplicant   # installing network management software and enabling its systemd unit so that it starts at boot
systemctl enable NetworkManager

#TODO Initramfs: For LVM, system encryption or RAID, modify mkinitcpio.conf(5) and recreate the initramfs image
# mkinitcpio -P

#echo root:password | chpasswd                            # set passwort for root user; script stops and waits for user input
printf "root:%s" "${initialPassword}" | sudo chpasswd     # set passwort for root user, using ${initialPassword} from config   # or: sudo chpasswd <<<"root:${initialPassword}"
passwd --expire root                                      # forces root user to change password at next login
# chage -l root                                           # list password expiration and aging information for root user

#TODO: function "install-grafics"
if [ "${graficsCardInstalled}" = "true" ]; then
    pacman -S --noconfirm "{strListGraficsCardPackage}"   # install packages for the grafics card
fi

#TODO: function "install-bootloader"
if [ "${bootloader}" = "grub" ]; then
    pacman -S --noconfirm grub                            # grub: install it

    if [ "${bootMode}" = "Bios" ]; then                   # Bios
        pacman -S --noconfirm grub
        grub-install --target=i386-pc "${device}"
    else                                                  # Uefi
        pacman -S --noconfirm efibootmgr
        grub-install --target=x86_64-efi --efi-directory="/${efiDir}" --bootloader-id="${bootloaderId}"
    fi

    grub-mkconfig -o /boot/grub/grub.cfg                  # grub config
fi

# --- Installation - additional packages and config ---
# or:
# --- Post-installation (after reboot)

#TODO: function "install-additionalPackages"
pacman -S --noconfirm "${strListAdditionalPkg}"
pacman -S --noconfirm "${strListAdditionalPkg_print}"
pacman -S --noconfirm "${strListAdditionalPkg_firewall}"
#pacman -S --noconfirm "${strListAdditionalPkg_PowerMgmt}" # TODO: query if corresponding variable is set -> install
yes | pacman -S "${strListAdditionalPkg_conflicting}"     # install packages with known conflicts an confirm prompt-question with yes
if [ "${virtualization}" = "true" ]; then
    #TODO: check cpu for virtualization support
    #TODO: nested virtualization
    pacman -S --noconfirm --needed "${strListAdditionalPkg_VM}"
    #TODO: config '/etc/libvirt/libvirtd.conf'   # set: unix_sock_group = "libvirt" # unix_sock_rw_perms = "0770"
    #TODO: add users to group 'libvirt'
fi
#pacman -S --noconfirm "${strListAdditionalPkg_zsh}"
#TODO: if zsh: echo "${zshSyntaxConf}" >> ~/.zshrc

#TODO: function "install-additionalPackages"
#systemctl enable NetworkManager   # already enabled, see network settings further above
systemctl enable bluetooth
systemctl enable cups.service
systemctl enable sshd
systemctl enable avahi-daemon
systemctl enable reflector.timer
systemctl enable fstrim.timer
if [ "${virtualization}" = "true" ]; then  systemctl enable libvirtd; fi 
systemctl enable firewalld
systemctl enable acpid
# systemctl enable tlp   #TODO: query if corresponding variable is set -> enable

#TODO: function "create-userAccount"
for userid in "${arrUserId[@]}"; do
    useradd -m -U -s /bin/bash "${userid}"
    #usermod -aG wheel
    if [ "${virtualization}" = "true" ]; then  usermod -aG libvirt "${userid}"; fi
done

for userid in "${arrSudoUser[@]}"; do
    echo "${userid} ALL=(ALL) ALL" >> "/etc/sudoers.d/sudoUser"
done
#EOF


# --- Reboot ---
#exit
umount -R /mnt
echo "!!! Finished !!!"
#echo "!!! Finished, rebooting in 3 seconds !!!"
#sleep 3 && reboot
